# **等价内化嵌套系统M1**

### **1. 语法 (Syntax)**

**1.1. 函数 (Functions)**

*   `·`：一个二元函数，表示**应用**。记为 `(· a b)`。
*   `equiv`：一个二元函数，表示**等价**。记为 `(equiv a b)`。

**1.2. 常量 (Constants)**

*   `T`：一个零元函数（原子项），代表**已证实的等价性**或**真理**。
*   `F`：一个零元函数（原子项）。

**1.3. 项 (Terms)**

项的集合由以下规则递归定义：
1.  `T` 是项。
2.  `F` 是项。
3.  若 `a` 和 `b` 是项，则 `(· a b)` 是项。
4.  若 `a` 和 `b` 是项，则 `(equiv a b)` 是项。

**1.4. 公式 (Formulas)**

公式的集合如下构成：
1. 若 `a` 和 `b` 是项，则  `a = b`是公式。
### **2. 证明论**

对于任意项 `a`, `b`, `c`, `d`, `f`, `x`：

**核心交互公理模式**

*   **A1: 内部交换 (Internal Commutation)**
    `(· (· a b) (equiv c d)) = (· (· c d) (equiv a b))`

*   **A2: 对偶应用 (Dual Application)**
    `(· (equiv a b) (equiv c d)) = (equiv (· a d) (· c b))`


**外化规则**

*    **A3: 外化规则**
```
	若 ⊢ (equiv a b) = T
	-------------------- (A3)
	则 ⊢ a = b
```

*   **A4: 内化规则**
```
	若 ⊢ a = b
	-------------------- (A4)
	则 ⊢ (equiv a b) = T
```

**背景等式逻辑 (Background Equational Logic)**

证明关系 `⊢` 由公理模式和推理规则归纳定义。以下结构性规则是 `⊢` 定义的一部分，它们共同确保了 ` = ` 作为一个全等关系 (congruence relation) 的性质。因此，`⊢` 满足等式逻辑并非一个外部假设，而是其定义的直接结果。对于任意项 `a`, `b`, `c`：

**公理模式：**
*   `Refl: a = a`

**推理规则：**
*   `Symm: a = b / b = a` (若 `⊢ a = b` 则 `⊢ b = a`)
*   `Trans: a = b, b = c / a = c`
*   `Cong-·: a = b / (· a c) = (· b c)` and `a = b / (· c a) = (· c b)`
*   `Cong-equiv: a = b / (equiv a c) = (equiv b c)` and `a = b / (equiv c a) = (equiv c b)`

### **3. 语义学与元理论 (Semantics and Metatheory)**

#### **3.1. 模型 M (The Model M)**

我们为系统 M1 构建一个代数模型 `M`。

**3.1.1. 域 (Domain)**
模型的论域 `D` 是集合 `{1, 0}`。

**3.1.2. 解释 (Interpretation)**
解释函数 `I` 将语法符号映射到域 `D` 上的元素和运算：
1.  **常量 (Constants)**
    *   `I(T) = 1`
    *   `I(F) = 0`

2.  **函数 (Functions)**
    *   `I(equiv)` 是一个二元函数 `equiv_M: D × D → D`，定义为：
        `equiv_M(x, y) = 1` 若 `x = y`
        `equiv_M(x, y) = 0` 若 `x ≠ y`

    *   `I(·)` 是一个二元函数 `·_M: D × D → D`，定义为：
        `x ·_M y = 1` 若 `x = y`
        `x ·_M y = 0` 若 `x ≠ y`

        其运算表如下：
| `·_M` | 1 | 0 |
| :---: |:-:|:-:|
| **1** | 1 | 0 |
| **0** | 0 | 1 |

**3.1.3. 求值 (Valuation)**
对于任意项 `t`，其在模型 `M` 中的值 `v(t)` 递归定义如下：
1.  `v(T) = I(T) = 1`
2.  `v(F) = I(F) = 0`
3.  `v((equiv a b)) = equiv_M(v(a), v(b))`
4.  `v((· a b)) = v(a) ·_M v(b)`

**3.1.4. 满足 (Satisfaction)**
一个公式 `a = b` 在模型 `M` 中为真，记为 `M ⊨ a = b`，当且仅当 `v(a) = v(b)`。

#### **3.2. 可靠性定理 (Soundness Theorem)**

**定理 (可靠性).** 对于任意项 `a`, `b`，若 `⊢ a = b`，则 `M ⊨ a = b`。

**证明.**
对证明 `⊢ a = b` 的长度 `n` 进行数学归纳法。

**1. 基础情况 (n=1)**
若证明长度为1，则 `a = b` 必为一个公理。我们须验证所有公理模式在 `M` 中均为真。对于任意项 `a, b, c, d`，令 `x_a=v(a)`, `x_b=v(b)`, `x_c=v(c)`, `x_d=v(d)`。

*   **Refl: `a = a`**
    `v(a) = v(a)`。根据元语言中等式的自反性，`M ⊨ a = a` 成立。

*   **A1: `(· (· a b) (equiv c d)) = (· (· c d) (equiv a b))`**
    LHS: `v((· (· a b) (equiv c d))) = v((· a b)) ·_M v((equiv c d)) = (x_a ·_M x_b) ·_M equiv_M(x_c, x_d)`
    RHS: `v((· (· c d) (equiv a b))) = v((· c d)) ·_M v((equiv a b)) = (x_c ·_M x_d) ·_M equiv_M(x_a, x_b)`
    由于 `·_M` 和 `equiv_M` 的定义相同，且该运算是可交换的，故 LHS = RHS。`M ⊨ A1` 成立。

*   **A2: `(· (equiv a b) (equiv c d)) = (equiv (· a d) (· c b))`**
    LHS: `v((· (equiv a b) (equiv c d))) = v((equiv a b)) ·_M v((equiv c d)) = equiv_M(x_a, x_b) ·_M equiv_M(x_c, x_d)`
    RHS: `v((equiv (· a d) (· c b))) = equiv_M(v((· a d)), v((· c b))) = equiv_M(x_a ·_M x_d, x_c ·_M x_b)`
    我们分情况验证 `LHS = RHS`：
    *   **情况 1: `x_a = x_b` 且 `x_c = x_d`**
        LHS = `equiv_M(x_a, x_a) ·_M equiv_M(x_c, x_c) = 1 ·_M 1 = 1`
        RHS = `equiv_M(x_a ·_M x_c, x_c ·_M x_a)`。因 `·_M` 可交换，`x_a ·_M x_c = x_c ·_M x_a`，故 RHS = `equiv_M(z, z) = 1`。
    *   **情况 2: `x_a = x_b` 且 `x_c ≠ x_d`**
        LHS = `equiv_M(x_a, x_a) ·_M equiv_M(x_c, x_d) = 1 ·_M 0 = 0`
        RHS = `equiv_M(x_a ·_M x_d, x_c ·_M x_b)`。因 `x_a=x_b`，RHS 为 `equiv_M(x_a ·_M x_d, x_c ·_M x_a)`。若 `x_a=1`，则变为 `equiv_M(1 ·_M x_d, x_c ·_M 1) = equiv_M(x_d, x_c)`。因 `x_c ≠ x_d`，RHS = 0。若 `x_a=0`，则变为 `equiv_M(0 ·_M x_d, x_c ·_M 0)`，其参数不等，RHS = 0。
    *   **情况 3: `x_a ≠ x_b` 且 `x_c = x_d`**
        与情况2对称，LHS = `0 ·_M 1 = 0`，RHS = 0。
    *   **情况 4: `x_a ≠ x_b` 且 `x_c ≠ x_d`**
        LHS = `equiv_M(x_a, x_b) ·_M equiv_M(x_c, x_d) = 0 ·_M 0 = 1`
        RHS = `equiv_M(x_a ·_M x_d, x_c ·_M x_b)`。因 `x_a ≠ x_b`, `x_c ≠ x_d`，可设 `x_b = 1-x_a`, `x_d = 1-x_c`。需证 `x_a ·_M (1-x_c) = x_c ·_M (1-x_a)`。`z ·_M (1-w)` 的值为1当且仅当 `z ≠ w`。`x_a ≠ x_c` 等价于 `x_c ≠ x_a`，故 `x_a ·_M (1-x_c)` 和 `x_c ·_M (1-x_a)` 的值恒等。因此 `RHS = equiv_M(z,z) = 1`。

所有情况下 `LHS = RHS`，故 `M ⊨ A2` 成立。

**2. 归纳步骤**
假设所有长度小于 `n` 的证明所得到的定理在 `M` 中都为真。考虑一个长度为 `n` 的证明，其最后一个公式 `a = b` 是由某个推理规则从前提推导而来。

*   **Symm: `c = d / d = c`**
    归纳假设：`M ⊨ c = d`，即 `v(c) = v(d)`。
    根据元语言中等式的对称性，`v(d) = v(c)`，即 `M ⊨ d = c`。

*   **Trans: `c = d, d = e / c = e`**
    归纳假设：`M ⊨ c = d` 且 `M ⊨ d = e`，即 `v(c) = v(d)` 且 `v(d) = v(e)`。
    根据元语言中等式的传递性，`v(c) = v(e)`，即 `M ⊨ c = e`。

*   **Cong-·: `c = d / (· c e) = (· d e)`**
    归纳假设：`M ⊨ c = d`，即 `v(c) = v(d)`。
    `v((· c e)) = v(c) ·_M v(e)`
    `v((· d e)) = v(d) ·_M v(e)`
    因 `v(c) = v(d)`，故 `v((· c e)) = v((· d e))`，即 `M ⊨ (· c e) = (· d e)`。
    另一条 `Cong-·` 规则同理可证。

*   **Cong-equiv: `c = d / (equiv c e) = (equiv d e)`**
    归纳假设：`M ⊨ c = d`，即 `v(c) = v(d)`。
    `v((equiv c e)) = equiv_M(v(c), v(e))`
    `v((equiv d e)) = equiv_M(v(d), v(e))`
    因 `v(c) = v(d)`，故 `v((equiv c e)) = v((equiv d e))`，即 `M ⊨ (equiv c e) = (equiv d e)`。
    另一条 `Cong-equiv` 规则同理可证。

*   **A3 (外化): `(equiv a b) = T / a = b`**
    归纳假设：`M ⊨ (equiv a b) = T`，即 `v((equiv a b)) = v(T)`。
    根据定义，`equiv_M(v(a), v(b)) = 1`。
    根据 `equiv_M` 的定义，这当且仅当 `v(a) = v(b)`。
    `v(a) = v(b)` 即 `M ⊨ a = b`。

*   **A4 (内化): `a = b / (equiv a b) = T`**
    归纳假设：`M ⊨ a = b`，即 `v(a) = v(b)`。
    根据 `equiv_M` 的定义，`equiv_M(v(a), v(b)) = 1`。
    所以 `v((equiv a b)) = 1`。
    又因 `v(T) = 1`，故 `v((equiv a b)) = v(T)`。
    即 `M ⊨ (equiv a b) = T`。

所有推理规则均保持真理性。根据数学归纳法原理，该定理成立。
Q.E.D.

#### **3.3. 非平凡一致性推论 (Corollary of Non-trivial Consistency)**

**推论 (非平凡一致性).** 系统 M1 是一致的，即 `⊬ T = F`。

**证明.**
采用反证法。
1.  **假设** `⊢ T = F`。
2.  根据可靠性定理 (3.2)，若 `⊢ T = F`，则 `M ⊨ T = F`。
3.  根据满足的定义 (3.1.4)，`M ⊨ T = F` 意味着 `v(T) = v(F)`。
4.  根据模型的解释 (3.1.2)，`v(T) = 1` 且 `v(F) = 0`。
5.  因此，`1 = 0`。这在元语言的算术中是一个矛盾。
6.  该矛盾源于初始假设。因此，假设 `⊢ T = F` 为假。

结论是 `⊬ T = F`。
Q.E.D.