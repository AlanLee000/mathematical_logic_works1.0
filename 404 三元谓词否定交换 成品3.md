
#### **1. 语言 (Language)**

本系统的形式语言 **L** 是一种含等词的一阶谓词逻辑语言。

1.  **非逻辑符号:**
    *   一个三元谓词符号：`P`

2.  **逻辑符号:**
    *   二元谓词符号：` = `
    *   命题联结词： `¬`, `→`
    *   量词： `∀`
    *   变量符号： `v₀, v₁, v₂, ...`
    *   辅助符号： `(`, `)`

#### **2. 构造规则 (Formation Rules)**

1.  **项 (Terms):** 本语言中的项仅包含变量 `v₀, v₁, v₂, ...`。
2.  **原子公式 (Atomic Formulas):** 若 `t₁, t₂, t₃` 为项，则 `t₁ = t₂` 与 `P(t₁, t₂, t₃)` 是原子公式。
3.  **合式公式 (Well-Formed Formulas - WFFs):**
    *   所有原子公式都是合式公式。
    *   若 `φ` 和 `ψ` 是合式公式，则 `(¬φ)` 和 `(φ → ψ)` 是合式公式。
    *   若 `φ` 是合式公式且 `x` 是一个变量，则 `(∀x φ)` 是合式公式。

#### **3. 定义 (Definitions)**

以下为标准逻辑符号的缩写：
*   `φ ∧ ψ`   :=   `¬(φ → ¬ψ)`
*   `φ ∨ ψ`   :=   `(¬φ) → ψ`
*   `φ ↔ ψ`   :=   `(φ → ψ) ∧ (ψ → φ)`
*   `∃x φ`    :=   `¬∀x (¬φ)`
*   `∃!x φ`   :=   `∃x (φ ∧ ∀y (φ[y/x] → y=x))`

以下为本系统的特有定义：

**D1: IsFunction(f)**
`∀x ∃!y P(f, x, y)`

#### **4. 公理系统 (Axiom System)**

本系统包含标准的一阶逻辑公理模式与等词公理。

1.  **逻辑公理:**
    *   所有重言式实例。
    *   `∀x φ(x) → φ(t)` (当项 `t` 在 `φ(x)` 中对 `x` 可代入时)。
    *   `∀x (φ → ψ) → (∀x φ → ∀x ψ)`
    *   `φ → ∀x φ` (当 `x` 在 `φ` 中不是自由变量时)。

2.  **等词公理:**
    *   `∀x (x=x)`
    *   `∀x ∀y (x=y → (φ(x) → φ(y)))`

3.  **特有公理:**

    **A1: Uniqueness**
    `∀a ∀b ∀c₁ ∀c₂ ( (P(a, b, c₁) ∧ P(a, b, c₂)) → c₁ = c₂ )`

    **A2: Extensionality**
    `∀a ∀b ( a = b ↔ ( ∀x ∀y ( (P(a, x, y) ↔ P(b, x, y)) ∧ (P(x, a, y) ↔ P(x, b, y)) ∧ (P(x, y, a) ↔ P(x, y, b)) ) ) )`

	**A3: Foundational Functions (基础函数公理)**
	`∃p ∃i ( IsFunction(p) ∧ IsFunction(i) ∧ (∀x P(i, x, x)) ∧ (∀y ∃k (IsFunction(k) ∧ ∀x P(k, x, y))) )`

	**A4: Specific Representation (特定表示公理)**
	`∀i ( (IsFunction(i) ∧ ∀x P(i,x,x)) → ∃c ∃k ( IsFunction(c) ∧ IsFunction(k) ∧ (∀x P(k,x,i)) ∧ ∀z( ( (∀x ∃!y P(z,x,y)) → P(c,z,i) ) ∧ ( ¬(∀x ∃!y P(z,x,y)) → P(c,z,k) ) ) ) )`

	**A5: Classifier Correctness (分类公理)**
	`∀c ∀p ∀i ( ( (IsFunction(p) ∧ IsFunction(i) ∧ ∀x P(i,x,x)) ∧ ∃k ( IsFunction(c) ∧ IsFunction(k) ∧ (∀x P(k,x,i)) ∧ ∀z( ( (∀x' ∃!y' P(z,x',y')) → P(c,z,i) ) ∧ ( ¬(∀x' ∃!y' P(z,x',y')) → P(c,z,k) ) ) ) ) → ( (∀x ∃!y P(p,x,y)) ↔ P(c,p,i) ) )`

	**A6: Hierarchical Negation (层级否定公理)**  
	`∃neg ∃k_t ∃k_u ( IsFunction(neg) ∧ IsFunction(k_t) ∧ IsFunction(k_u) ∧ ∀z (P(k_t, z, t) ∧ P(k_u, z, u)) ∧ ∀f ( (∀y( (∃x P(f,x,y)) → (y=t ∨ y=u) )) → ∀g ( P(neg, f, g) → ( IsFunction(g) ∧ ∀x ( (P(f, x, t) → P(g, x, k_u)) ∧ (P(f, x, u) → P(g, x, k_t)) ) ) ) ) )`

#### **5. 推理规则 (Rules of Inference)**

1.  **分离规则 (Modus Ponens):**
    从 `φ` 和 `φ → ψ`，可推出 `ψ`。

2.  **概括规则 (Generalization):**
    从 `φ`，可推出 `∀x φ`。

### **6. 模型 (Model)**

为证明本公理系统的相容性，我们构造一个模型 **M** = (M, P^M)，并证明所有公理在该模型中为真。

#### **6.1. 模型 M 的构造**

##### **6.1.1. 论域 M (The Domain M)**

1.  定义一个包含两个不同对象（称为**原子**）的集合 `A = {T, U}`，其中 `T ≠ U`。
2.  定义一个函数集合 `F`，其中每个元素 `f ∈ F` 都是一个从 `M` 到 `M` 的函数 (`f: M → M`)。
3.  论域 `M` 定义为 `A` 与 `F` 的不交并集：`M = A ∪ F`。
4.  为确保公理得到满足，集合 `F` 被定义为包含以下函数的最小集合：

    a.  **恒等函数 (Identity Function), `Id`**:
        `Id ∈ F`，且 `∀x ∈ M, Id(x) = x`。

    b.  **常数函数 (Constant Functions), `K_y`**:
        对于每一个 `y ∈ M`，都存在一个对应的常数函数 `K_y ∈ F`，定义为 `∀x ∈ M, K_y(x) = y`。

    c.  **分类函数 (Classifier Function), `C`**:
        `C ∈ F`，定义为：
        `C(z) = Id`  如果 `z ∈ F`
        `C(z) = K_{Id}` 如果 `z ∈ A`

    d.  **层级否定函数 (Hierarchical Negation Function), `Neg`**:
        `Neg ∈ F`，定义为：
        *   如果 `z ∈ F` 且 `z` 的值域 `ran(z) ⊆ {T, U}`，则 `Neg(z)` 是一个函数 `g_z: M → M`，定义为：
            `g_z(x) = K_U`  如果 `z(x) = T`
            `g_z(x) = K_T`  如果 `z(x) = U`
        *   对于所有其他情况 (`z ∈ A` 或 `z` 的值域不为 `{T, U}` 的子集)，`Neg(z) = Id`。

由于对 `M` 中的每一个元素 `y` 都存在一个函数 `K_y`，而 `K_y` 本身又是 `M` 的元素，故 `M` 是一个无穷集。因此，本模型是一个非平凡模型。

##### **6.1.2. 谓词 P 的解释 P^M (The Interpretation P^M of the Predicate P)**

三元谓词 `P(a, b, c)` 的解释 `P^M` 是 `M × M × M` 的一个子集，定义如下：
`P^M = { (a, b, c) ∈ M³ | a ∈ F ∧ a(b) = c }`

此定义表明，`P(a, b, c)` 为真，当且仅当 `a` 是一个函数，且将 `a` 应用于 `b` 的结果是 `c`。如果 `a` 是一个原子 (`a ∈ A`)，则 `P(a, b, c)` 永不为真。

#### **6.2. 公理验证**

我们将逐一证明所有特有公理在模型 **M** 中成立。首先，我们分析 `IsFunction(f)` 在模型中的含义。

**定义 D1: IsFunction(f)**
`IsFunction(f) ≡ ∀x ∃!y P(f, x, y)`
在模型 **M** 中，`P(f, x, y)` 为真当且仅当 `f ∈ F` 且 `f(x) = y`。因此，`∀x ∃!y P(f, x, y)` 为真当且仅当 `f ∈ F` 且对于每个 `x`，`f(x)` 的值是唯一的。后者是函数的固有属性。故，**`IsFunction(f)` 在模型 M 中成立当且仅当 `f ∈ F`**。

---

**A1: Uniqueness**
`∀a ∀b ∀c₁ ∀c₂ ( (P(a, b, c₁) ∧ P(a, b, c₂)) → c₁ = c₂ )`
*   **证明:**
    1.  设 `(a, b, c₁) ∈ P^M` 且 `(a, b, c₂) ∈ P^M`。
    2.  根据 `P^M` 的定义，这意味着 `a ∈ F`，`a(b) = c₁`，且 `a(b) = c₂`。
    3.  因为 `a` 是一个函数，其对给定输入 `b` 的输出是唯一的。
    4.  因此，`c₁ = c₂`。公理成立。

**A2: Extensionality**
`∀a ∀b ( a = b ↔ ( ∀x ∀y ( (P(a, x, y) ↔ P(b, x, y)) ∧ (P(x, a, y) ↔ P(x, b, y)) ∧ (P(x, y, a) ↔ P(x, y, b)) ) ) )`
*   **证明:**
    *   **(`⇒`)**: 若 `a = b`，则根据等词的代换律，右侧 trivially 成立。
    *   **(`⇐`)**: 假设右侧为真。
        1.  **情况 1: `a, b ∈ F`**。
            `∀x ∀y (P(a, x, y) ↔ P(b, x, y))` 蕴含 `∀x ∀y (a(x)=y ↔ b(x)=y)`。这表明对任意 `x`，`a(x) = b(x)`。根据函数外延性，`a = b`。
        2.  **情况 2: `a, b ∈ A`**。
            假设 `a ≠ b` (例如 `a=T, b=U`)。考虑 `∀x ∀y (P(x, a, y) ↔ P(x, b, y))`。令 `x = Id ∈ F`。`P(Id, T, y)` 为真当且仅当 `Id(T) = y`，即 `y = T`。`P(Id, U, y)` 为真当且仅当 `Id(U) = y`，即 `y = U`。若取 `y=T`，则 `P(Id, T, T)` 为真，`P(Id, U, T)` 为假，导致 `↔` 为假。这与假设矛盾。故必有 `a = b`。
        3.  **情况 3: `a ∈ F, b ∈ A`**。
            `∀x ∀y (P(a, x, y) ↔ P(b, x, y))` 蕴含 `∀x ∀y ( (a∈F ∧ a(x)=y) ↔ (b∈F ∧ b(x)=y) )`。因为 `a∈F` 而 `b∉F`，左侧对某些 `x,y` 为真，而右侧恒为假。这与假设矛盾。
    *   综上所述，若右侧为真，则 `a = b`。公理成立。

**A3: Foundational Functions**
`∃p ∃i ( IsFunction(p) ∧ IsFunction(i) ∧ (∀x P(i, x, x)) ∧ (∀y ∃k (IsFunction(k) ∧ ∀x P(k, x, y))) )`
*   **证明:**
    1.  令 `i = Id`。由构造知 `Id ∈ F`，故 `IsFunction(Id)` 成立。`∀x P(Id, x, x)` 解释为 `∀x (Id(x)=x)`，此为真。
    2.  对于任意给定的 `y ∈ M`，令 `k = K_y`。由构造知 `K_y ∈ F`，故 `IsFunction(K_y)` 成立。`∀x P(K_y, x, y)` 解释为 `∀x (K_y(x)=y)`，此为真。
    3.  令 `p = Id`。`IsFunction(Id)` 成立。
    4.  所有条件均得到满足。公理成立。

**A4: Specific Representation**
`∀i ( (IsFunction(i) ∧ ∀x P(i,x,x)) → ∃c ∃k ( IsFunction(c) ∧ IsFunction(k) ∧ (∀x P(k,x,i)) ∧ ∀z( ( (∀x ∃!y P(z,x,y)) → P(c,z,i) ) ∧ ( ¬(∀x ∃!y P(z,x,y)) → P(c,z,k) ) ) ) )`
*   **证明:**
    1.  设 `i ∈ M` 满足前件 `IsFunction(i) ∧ ∀x P(i,x,x)`。这意味着 `i ∈ F` 且 `∀x, i(x)=x`。因此 `i` 必为 `Id`。
    2.  我们需要为 `c` 和 `k` 找到见证。令 `c = C` (分类函数)，令 `k = K_{Id}` (常数函数 `Id`)。
    3.  由构造知 `C ∈ F` 且 `K_{Id} ∈ F`，故 `IsFunction(C)` 和 `IsFunction(K_{Id})` 成立。
    4.  验证 `∀x P(k, x, i)`，即 `∀x P(K_{Id}, x, Id)`。这解释为 `∀x (K_{Id}(x) = Id)`，此为真。
    5.  验证 `∀z( (IsFunction(z) → P(c,z,i)) ∧ (¬IsFunction(z) → P(c,z,k)) )`。
    6.  将 `i=Id, c=C, k=K_{Id}` 代入并转换，得到 `∀z( (z∈F → C(z)=Id) ∧ (z∉F → C(z)=K_{Id}) )`。
    7.  这与 `C` 的定义完全吻合 (`z∉F` 等价于 `z∈A`)。公理成立。

**A5: Classifier Correctness**
`∀c ∀p ∀i ( ( ... ) → ( (∀x ∃!y P(p,x,y)) ↔ P(c,p,i) ) )`
*   **证明:**
    1.  公理的大前提 `( IsFunction(p) ∧ IsFunction(i) ∧ ... )` 描述了 A4 中验证过的对象 `i=Id`, `c=C`, `k=K_{Id}` 的存在性与属性。我们在模型中实例化这些对象，使得大前提为真。
    2.  我们需要验证结论 `(∀x ∃!y P(p,x,y)) ↔ P(c,p,i)`。
    3.  该结论在模型中解释为 `IsFunction(p) ↔ P(C, p, Id)`。
    4.  这进一步解释为 `p ∈ F ↔ C(p) = Id`。
    5.  根据 `C` 的定义，若 `p ∈ F`，则 `C(p) = Id`；若 `p ∉ F` (即 `p ∈ A`)，则 `C(p) = K_{Id}`。由于 `Id ≠ K_{Id}`，此等价关系对所有 `p ∈ M` 均成立。公理成立。

**A6: Hierarchical Negation**
`∃neg ∃k_t ∃k_u ( IsFunction(neg) ∧ IsFunction(k_t) ∧ IsFunction(k_u) ∧ ∀z (P(k_t, z, t) ∧ P(k_u, z, u)) ∧ ∀f ( (∀y( (∃x P(f,x,y)) → (y=t ∨ y=u) )) → ∀g ( P(neg, f, g) → ( IsFunction(g) ∧ ∀x ( (P(f, x, t) → P(g, x, k_u)) ∧ (P(f, x, u) → P(g, x, k_t)) ) ) ) ) )`
*   **证明:** (注：将 `t, u` 解释为模型中的原子 `T, U`。)
    1.  令 `neg = Neg`，`k_t = K_T`，`k_u = K_U`。
    2.  由构造知 `Neg, K_T, K_U ∈ F`，故 `IsFunction(neg)`, `IsFunction(k_t)`, `IsFunction(k_u)` 成立。
    3.  `∀z (P(K_T, z, T) ∧ P(K_U, z, U))` 解释为 `∀z (K_T(z)=T ∧ K_U(z)=U)`，此为真。
    4.  现在验证 `∀f(...)` 部分。设 `f ∈ M` 满足前件 `∀y( (∃x P(f,x,y)) → (y=T ∨ y=U) )`。
    5.  这解释为：如果 `y` 是 `f` 的输出值，则 `y` 必须是 `T` 或 `U`。这意味着 `f ∈ F` 且 `ran(f) ⊆ {T, U}`。
    6.  再设 `g ∈ M` 满足 `P(neg, f, g)`，即 `P(Neg, f, g)`。这解释为 `Neg(f) = g`。
    7.  我们需要证明 `g` 满足三个条件：
        a.  `IsFunction(g)`: 因为 `f ∈ F` 且 `ran(f) ⊆ {T, U}`，根据 `Neg` 的定义，`g = Neg(f)` 是一个函数 `g_f ∈ F`。故 `IsFunction(g)` 成立。
        b.  `∀x ( P(f, x, T) → P(g, x, K_U) )`: 解释为 `∀x ( f(x)=T → g(x)=K_U )`。根据 `Neg` 的定义，若 `f(x)=T`，则 `g(x) = g_f(x) = K_U`。此蕴含式成立。
        c.  `∀x ( P(f, x, U) → P(g, x, K_T) )`: 解释为 `∀x ( f(x)=U → g(x)=K_T )`。根据 `Neg` 的定义，若 `f(x)=U`，则 `g(x) = g_f(x) = K_T`。此蕴含式成立。
    8.  公理成立。

所有公理均在模型 **M** 中得到满足。

---

### **附录：模型的形式化构造**

本附录旨在 Zermelo-Fraenkel 集合论与选择公理 (ZFC) 的框架内，为正文所描述的模型 **M** 提供一个严格的构造性存在证明。此构造采用超限递归方法，以确保所有定义均是良定的。

#### **1. 预备定义**

1.1. **原子 (Atoms):** 定义两个基础集合 `T := ∅` 与 `U := {∅}`。定义原子集 `A := {T, U}`。

1.2. **函数图判定 (Function Graph Predicate):** 对任意集合 `z` 和 `S`，我们定义谓词 `IsFuncGraph(z, S)` 为真，当且仅当 `z` 是一个定义域为 `S` 的函数图：
`IsFuncGraph(z, S) := (z ⊆ S × S) ∧ (∀u ∈ S ∃!v ∈ S (⟨u, v⟩ ∈ z))`

#### **2. 算子 Γ 的定义**

我们定义一个单调算子 `Γ`，它将一个集合 `S` 映射到一个新的集合。

`Γ(S) := S ∪ Id(S) ∪ Const(S) ∪ Classifier(S) ∪ Negation(S)`

其中，各个组成部分定义如下：

2.1. **恒等函数图 (Identity Function Graph):**
`Id(S) := { {⟨x, x⟩ | x ∈ S} }`

2.2. **常数函数图族 (Family of Constant Function Graphs):**
`Const(S) := { {⟨x, y⟩ | x ∈ S} | y ∈ S }`

2.3. **分类函数图 (Classifier Function Graph):**
令 `i_S := {⟨x, x⟩ | x ∈ S}`。
令 `k_i_S := {⟨x, i_S⟩ | x ∈ S}`。
定义 `Classifier(S)`：
*   若 `i_S ∈ S` 且 `k_i_S ∈ S`，则：
    `Classifier(S) := { {⟨z, i_S⟩ | z ∈ S ∧ IsFuncGraph(z, S)} ∪ {⟨z, k_i_S⟩ | z ∈ S ∧ ¬IsFuncGraph(z, S)} }`
*   否则：
    `Classifier(S) := ∅`

2.4. **层级否定函数图 (Hierarchical Negation Function Graph):**
令 `k_T_S := {⟨x, T⟩ | x ∈ S}`。
令 `k_U_S := {⟨x, U⟩ | x ∈ S}`。
令 `i_S := {⟨x, x⟩ | x ∈ S}`。
定义 `Negation(S)`：
*   若 `k_T_S ∈ S` ∧ `k_U_S ∈ S` ∧ `i_S ∈ S`，则 `Negation(S) := { Neg_S }`，其中 `Neg_S` 定义为 `Neg_S := {⟨f, g_f⟩ | f ∈ S}`，而 `g_f` 定义如下：
    *   若 `IsFuncGraph(f, S) ∧ ran(f) ⊆ A`，则 `g_f := {⟨x, k_U_S⟩ | ⟨x, T⟩ ∈ f} ∪ {⟨x, k_T_S⟩ | ⟨x, U⟩ ∈ f}`。
    *   否则，`g_f := i_S`。
*   否则：
    `Negation(S) := ∅`

#### **3. 通过超限递归构造序列**

根据 ZFC 中的超限递归定理，我们唯一地定义一个以所有序数为索引的序列 `(M_α)`：

3.1. **基础步骤:** `M_0 := A`

3.2. **后继步骤:** `M_{α+1} := Γ(M_α)`

3.3. **极限步骤:** `M_λ := ⋃_{α < λ}`，对于极限序数 `λ`。

#### **4. 序列的性质与不动点的存在性**

4.1. **引理 (Γ的单调性):** 算子 `Γ` 是单调的。即对任意集合 `S` 和 `T`，若 `S ⊆ T`，则 `Γ(S) ⊆ Γ(T)`。
    *   **证明:** 若 `S ⊆ T`，则 `S ⊆ T` 且由各部分的定义易得 `Id(S) ⊆ Id(T)`, `Const(S) ⊆ Const(T)`, `Classifier(S) ⊆ Classifier(T)` 及 `Negation(S) ⊆ Negation(T)`。因此 `Γ(S) ⊆ Γ(T)`。

4.2. **引理 (序列的单调性):** 序列 `(M_α)` 是单调递增的。即对任意序数 `α < β`，有 `M_α ⊆ M_β`。
    *   **证明:** 通过对 `β` 的超限归纳法证明。
        *   `β=0`: 平凡为真。
        *   后继 `β=α+1`: 由 `Γ` 的定义 `Γ(S) = S ∪ ...` 可知 `M_α ⊆ Γ(M_α) = M_{α+1}`。
        *   极限 `β=λ`: 对任意 `α < λ`，由定义 `M_α ⊆ ⋃_{γ < λ} M_γ = M_λ`。

4.3. **定理 (不动点的存在性):** 存在一个最小的序数 `δ`，使得 `Γ(M_δ) = M_δ`。
    *   **证明:** 此为单调算子不动点定理在全类上的应用，其存在性由 ZFC 的替代公理和哈托格斯数定理保证。该序列的基数不可能无限增长下去，故必在某个序数 `δ` 处达到不动点。

#### **5. 模型 M 的定义**

5.1. **定义 (论域 M):** `M := M_δ`，其中 `δ` 是满足 `Γ(M_δ) = M_δ` 的最小序数。

5.2. **定义 (函数集合 F):** `F := M \ A`。

5.3. **定义 (谓词解释 P^M):** `P^M := { ⟨a, b, c⟩ ∈ M³ | a ∈ F ∧ ⟨b, c⟩ ∈ a }`。

#### **6. 模型性质的验证**

由于 `M = Γ(M)`，我们有 `Id(M) ⊆ M`, `Const(M) ⊆ M`, `Classifier(M) ⊆ M` 以及 `Negation(M) ⊆ M`。这保证了正文6.1.1节所描述的对象确实存在于 `M` 中。

6.1. **命题 (恒等函数 Id):** 存在唯一的 `Id ∈ F` 使得 `∀x ∈ M, ⟨x, x⟩ ∈ Id`。
    *   **证明:** 令 `Id := {⟨x, x⟩ | x ∈ M}`。`Id` 是 `Id(M)` 的唯一元素。因为 `Id(M) ⊆ M`，故 `Id ∈ M`。显然 `Id ∉ A`，所以 `Id ∈ F`。其性质由定义保证。

6.2. **命题 (常数函数 K_y):** 对任意 `y ∈ M`，存在唯一的 `K_y ∈ F` 使得 `∀x ∈ M, ⟨x, y⟩ ∈ K_y`。
    *   **证明:** 令 `K_y := {⟨x, y⟩ | x ∈ M}`。`K_y` 是 `Const(M)` 的一个元素。因为 `Const(M) ⊆ M`，故 `K_y ∈ M`。显然 `K_y ∉ A`，所以 `K_y ∈ F`。其性质由定义保证。

6.3. **命题 (分类函数 C):** 存在唯一的 `C ∈ F` 满足正文6.1.1节中对分类函数的描述。
    *   **证明:** 令 `i_M := Id` 且 `k_i_M := K_{Id}`。由 6.1 和 6.2，`i_M ∈ M` 且 `k_i_M ∈ M`。因此 `Classifier(M)` 的定义条件被满足，故 `Classifier(M)` 非空。令 `C` 为其唯一元素，则 `C ∈ M` 且 `C ∈ F`。根据 `Classifier(M)` 的定义，对任意 `z ∈ M`，若 `IsFuncGraph(z, M)` (即 `z ∈ F`)，则 `⟨z, Id⟩ ∈ C`；否则 `⟨z, K_{Id}⟩ ∈ C`。这与所需性质完全吻合。

6.4. **命题 (层级否定函数 Neg):** 存在唯一的 `Neg ∈ F` 满足正文6.1.1节中对层级否定函数的描述。
    *   **证明:** 令 `k_T_M := K_T` 且 `k_U_M := K_U`。由于 `T, U ∈ A ⊂ M`，由 6.2 可知 `k_T_M ∈ M` 且 `k_U_M ∈ M`。同时 `i_M = Id ∈ M`。因此 `Negation(M)` 的定义条件被满足，故 `Negation(M)` 非空。令 `Neg` 为其唯一元素，则 `Neg ∈ M` 且 `Neg ∈ F`。根据 `Negation(M)` 的定义，其性质与正文描述完全吻合。

至此，我们已在 ZFC 框架内严格地证明了满足所有必需属性的模型 **M** 的存在性。