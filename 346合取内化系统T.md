### **1. 形式系统 `T`**

#### **1.1 语言 `L`**

*   **字母表 (Alphabet):**
    *   变量符号: `x, y, z, a, ...` (一个可数无限集 `V`)
    *   常量符号: `c` (可选，此处不使用)
    *   函数符号: `f` (二元)
    *   谓词符号: `P` (二元), ` = ` (二元)
    *   逻辑连接词: `¬`, `→`
    *   量词: `∀`
    *   辅助符号: `(`, `)`

*   **项 (Terms):**
    1.  任何变量 `v ∈ V` 都是项。
    2.  如果 `t₁`, `t₂` 是项，那么 `f(t₁, t₂)` 是项。

*   **原子公式 (Atomic Formulas):**
    1.  如果 `t₁`, `t₂` 是项，那么 `t₁ = t₂` 是原子公式。
    2.  如果 `t₁`, `t₂` 是项，那么 `P(t₁, t₂)` 是原子公式。

*   **公式 (Well-Formed Formulas, WFFs):**
    1.  任何原子公式都是公式。
    2.  如果 `φ` 是公式，那么 `¬φ` 是公式。
    3.  如果 `φ`, `ψ` 是公式，那么 `(φ → ψ)` 是公式。
    4.  如果 `φ` 是公式且 `v ∈ V`，那么 `∀v φ` 是公式。
    *（其他连接词 `∧, ∨, ⇔` 和量词 `∃` 可作为标准宏定义）*

#### **1.2 证明论 (Proof Theory)**

该系统 `T` 基于带等词的一阶谓词逻辑（FOL with Equality），其公理和规则如下：

*   **逻辑公理模式:**
    *   `A1: φ → (ψ → φ)`
    *   `A2: (φ → (ψ → χ)) → ((φ → ψ) → (φ → χ))`
    *   `A3: (¬ψ → ¬φ) → ((¬ψ → φ) → ψ)`
    *   `A4: ∀v φ(v) → φ(t)` (其中项 `t` 可自由代入 `v`)
    *   `A5: ∀v (φ → ψ) → (φ → ∀v ψ)` (其中 `v` 在 `φ` 中不自由出现)

*   **等词公理:**
    *   `E1: ∀v (v = v)` (自反性)
    *   `E2: ∀u∀v (u = v → (φ(u) → φ(v)))` (替换律)

*   **推理规则:**
    *   **肯定前件 (Modus Ponens):** 从 `φ` 和 `φ → ψ`，可推出 `ψ`。
    *   **普遍概括 (Generalization):** 从 `φ`，可推出 `∀v φ`。

*   **`T` 的非逻辑公理:**
    *   **Axiom T1 (广义结合律):** `∀x∀y∀z (P(f(x,y), z) ⇔ P(x, f(y,z)))`
    *   **Axiom T2 (广义交换律):** `∀x∀y∀a (P(a, f(x,y)) ⇔ P(a, f(y,x)))`
    *   **Axiom T3 (外延性):** `∀y∀z ((∀a∀x (P(a,f(x,y)) ⇔ P(a,f(x,z)))) → (P(y,z) ∧ P(z,y)))`

**定义:** `T ⊢ φ` 表示公式 `φ` 可在系统 `T` 中被证明。

### **2. 模型、可靠性与一致性**

本节旨在为形式系统 `T` 构建一个模型，并基于此模型证明 `T` 的可靠性与非平凡一致性。

#### **2.1 模型的构建**

**定义 2.1.1 (模型 `M`)**.
我们定义一个 `L`-结构 `M = <U, f^M, P^M>`，其各组成部分如下：

1.  **论域 (Universe):** `U` 是自然数集 `ℕ = {0, 1, 2, ...}`。
    *   注意 `|U| = ℵ₀`，因此 `U` 是一个无限集且 `|U| > 1`。

2.  **函数解释 (Interpretation of `f`):** `f^M` 是 `U` 上的二元加法运算 `+`。
    *   `f^M: U × U → U`
    *   对于任意 `n₁, n₂ ∈ U`，`f^M(n₁, n₂) := n₁ + n₂`。

3.  **谓词解释 (Interpretation of `P`):** `P^M` 是 `U` 上的二元关系“同余模 2”。
    *   `P^M ⊆ U × U`
    *   对于任意 `n₁, n₂ ∈ U`，`<n₁, n₂> ∈ P^M` 当且仅当 `n₁ ≡ n₂ (mod 2)`。

4.  **等词解释 (Interpretation of ` = `)**: 按照标准语义，` = ` 被解释为 `U` 上的恒等关系。

#### **2.2 模型验证**

为证明 `M` 是 `T` 的一个模型 (记为 `M ⊨ T`)，我们必须证明 `T` 的所有非逻辑公理在 `M` 的解释下为真。

**命题 2.2.1**. `M ⊨ ∀x∀y∀z (P(f(x,y), z) ⇔ P(x, f(y,z)))`。

**证明**.
根据 `L`-结构中公式为真的语义定义，我们需要证明对于任意赋值函数 `s: V → U`，有 `M, s ⊨ P(f(x,y), z) ⇔ P(x, f(y,z))`。令 `s(x)=nₓ`, `s(y)=nᵧ`, `s(z)=n₂` 为 `U` 中的任意元素。

1.  `M, s ⊨ P(f(x,y), z)`
    ⇔ `<(f(x,y))^M, z^M> ∈ P^M` (根据 `P` 的语义)
    ⇔ `<f^M(x^M, y^M), z^M> ∈ P^M` (根据项的语义)
    ⇔ `<f^M(nₓ, nᵧ), n₂> ∈ P^M`
    ⇔ `<nₓ + nᵧ, n₂> ∈ P^M` (根据 `f^M` 的定义)
    ⇔ `(nₓ + nᵧ) ≡ n₂ (mod 2)` (根据 `P^M` 的定义)。

2.  `M, s ⊨ P(x, f(y,z))`
    ⇔ `<x^M, (f(y,z))^M> ∈ P^M`
    ⇔ `<x^M, f^M(y^M, z^M)> ∈ P^M`
    ⇔ `<nₓ, f^M(nᵧ, n₂)> ∈ P^M`
    ⇔ `<nₓ, nᵧ + n₂> ∈ P^M`
    ⇔ `nₓ ≡ (nᵧ + n₂) (mod 2)`。

3.  因此，我们需证明 `(nₓ + nᵧ) ≡ n₂ (mod 2) ⇔ nₓ ≡ (nᵧ + n₂) (mod 2)`。
    *   `(nₓ + nᵧ) ≡ n₂ (mod 2)` 等价于 `(nₓ + nᵧ) - n₂` 是 2 的倍数。
    *   `nₓ ≡ (nᵧ + n₂) (mod 2)` 等价于 `nₓ - (nᵧ + n₂)` 是 2 的倍数。
    *   考察差值：`((nₓ + nᵧ) - n₂) - (nₓ - (nᵧ + n₂)) = (nₓ + nᵧ - n₂) - (nₓ - nᵧ - n₂) = 2nᵧ`。
    *   因为 `2nᵧ` 是 2 的倍数，所以 `(nₓ + nᵧ - n₂)` 与 `(nₓ - nᵧ - n₂)` 的奇偶性相同。
    *   故 `(nₓ + nᵧ - n₂)` 是 2 的倍数当且仅当 `(nₓ - nᵧ - n₂)` 是 2 的倍数。
    *   此即证明了该等价关系成立。

由于 `nₓ, nᵧ, n₂` 是任意的，公理 T1 在 `M` 中为真。

**命题 2.2.2**. `M ⊨ ∀x∀y∀a (P(a, f(x,y)) ⇔ P(a, f(y,x)))`。

**证明**.
令 `s(x)=nₓ`, `s(y)=nᵧ`, `s(a)=nₐ` 为 `U` 中的任意元素。
1.  `M, s ⊨ P(a, f(x,y))` ⇔ `nₐ ≡ (nₓ + nᵧ) (mod 2)`。
2.  `M, s ⊨ P(a, f(y,x))` ⇔ `nₐ ≡ (nᵧ + nₓ) (mod 2)`。
3.  由于自然数加法满足交换律，`nₓ + nᵧ = nᵧ + nₓ`。
4.  因此，两个同余式是等价的。公理 T2 在 `M` 中为真。

**命题 2.2.3**. `M ⊨ ∀y∀z ((∀a∀x (P(a,f(x,y)) ⇔ P(a,f(x,z)))) → (P(y,z) ∧ P(z,y)))`。

**证明**.
令 `s(y)=nᵧ`, `s(z)=n₂` 为 `U` 中的任意元素。我们需要证明该蕴含式为真。假设其前件为真，并证明其后件亦为真。

1.  **假设 (Antecedent):**
    `M, s ⊨ ∀a∀x (P(a,f(x,y)) ⇔ P(a,f(x,z)))`。
    这意味着对于任意 `nₐ, nₓ ∈ U`，以下等价关系成立：
    `(H): M, s[a↦nₐ, x↦nₓ] ⊨ P(a,f(x,y)) ⇔ M, s[a↦nₐ, x↦nₓ] ⊨ P(a,f(x,z))`
    即 `nₐ ≡ (nₓ + nᵧ) (mod 2) ⇔ nₐ ≡ (nₓ + n₂) (mod 2)`。

2.  **推导 (Derivation):**
    由于 `(H)` 对任意 `nₐ, nₓ` 均成立，我们可以选择特定值。
    *   令 `nₓ = 0`。则 `(H)` 蕴含：对于任意 `nₐ ∈ U`，
        `(H'): nₐ ≡ nᵧ (mod 2) ⇔ nₐ ≡ n₂ (mod 2)`。
    *   由于 `(H')` 对任意 `nₐ` 成立，令 `nₐ = nᵧ`。则 `(H')` 蕴含：
        `nᵧ ≡ nᵧ (mod 2) ⇔ nᵧ ≡ n₂ (mod 2)`。
    *   `nᵧ ≡ nᵧ (mod 2)` 因同余关系的自反性而为真。
    *   设 `p` 为 `nᵧ ≡ nᵧ (mod 2)`，`q` 为 `nᵧ ≡ n₂ (mod 2)`。我们有 `p` 为真且 `(p ⇔ q)` 为真。根据命题逻辑，这蕴含 `q` 为真。
    *   因此，`nᵧ ≡ n₂ (mod 2)` 成立。

3.  **结论 (Consequent):**
    我们已证明 `nᵧ ≡ n₂ (mod 2)`。根据同余关系的对称性，`n₂ ≡ nᵧ (mod 2)` 亦成立。
    这对应于 `M, s ⊨ P(y,z) ∧ P(z,y)`。
    由于从前件的真可以推导出后件的真，该蕴含式成立。公理 T3 在 `M` 中为真。

**定理 2.2.4**. `M` 是 `T` 的一个模型。
**证明**. `M` 满足 `T` 的所有非逻辑公理 T1, T2, T3。根据定义，`M` 是 `T` 的一个模型。

#### **2.3 可靠性与一致性**

**定理 2.3.1 (一阶逻辑可靠性定理)**.
令 `Γ` 为一个 `L`-语句集，`φ` 为一个 `L`-语句。如果 `Γ ⊢ φ`，则 `Γ ⊨ φ`（即对于 `Γ` 的每一个模型 `M'`，都有 `M' ⊨ φ`）。

**推论 2.3.2 (T 相对于 M 的可靠性)**.
对于任意 `L`-公式 `φ`，如果 `T ⊢ φ`，则 `M ⊨ φ`。
**证明**. 设 `T` 为公理集 `Γ`。由定理 2.2.4，`M` 是 `T` 的一个模型。根据定理 2.3.1，若 `T ⊢ φ`，则 `T ⊨ φ`，这意味着 `φ` 在 `T` 的所有模型中都为真。因此，`M ⊨ φ`。

**定义 2.3.3 (一致性)**.
一个理论 `T` 被称为**一致的 (consistent)**，当且仅当不存在任何公式 `φ`，使得 `T ⊢ φ` 且 `T ⊢ ¬φ`。这等价于 `T` 不能证明矛盾，即 `T ⊬ (φ ∧ ¬φ)`。

**定理 2.3.4 (T 的一致性)**.
理论 `T` 是一致的。
**证明**.
1.  以反证法证明。假设 `T` 是不一致的。
2.  根据定义 2.3.3，存在某个公式 `φ`，使得 `T ⊢ (φ ∧ ¬φ)`。
3.  根据推论 2.3.2 (可靠性)，可得 `M ⊨ (φ ∧ ¬φ)`。
4.  根据 `L` 的语义，`M ⊨ (φ ∧ ¬φ)` 意味着 `M ⊨ φ` 且 `M ⊨ ¬φ`。
5.  `M ⊨ ¬φ` 意味着 `M <binary data, 2 bytes> φ`。
6.  因此，我们得到 `M ⊨ φ` 且 `M <binary data, 2 bytes> φ`。这是一个矛盾。
7.  此矛盾源于 `T` 不一致的假设。故假设为假，`T` 是一致的。

**定义 2.3.5 (非平凡一致性)**.
一个理论 `T` 被称为**非平凡一致的 (non-trivially consistent)**，如果 `T` 是一致的且至少拥有一个基数大于 1 的模型。

**定理 2.3.6 (T 的非平凡一致性)**.
理论 `T` 是非平凡一致的。
**证明**.
1.  由定理 2.3.4，`T` 是一致的。
2.  由定义 2.1.1，我们构建的模型 `M` 的论域是 `U = ℕ`。
3.  `|U| = ℵ₀ > 1`。
4.  因此，`T` 存在一个基数大于 1 的模型。
5.  根据定义 2.3.5，`T` 是非平凡一致的。
    *   一个直接的后果是，`T` 不能证明所有元素都相等，即 `T ⊬ ∀x∀y(x=y)`，因为该语句在模型 `M` 中为假（例如，`M <binary data, 2 bytes> 0=1`）。

---

### **3. 公理的独立性与相对一致性**

本节旨在探究系统 `T` 的一个潜在扩展，即引入一个新的公理。我们将通过模型论的方法证明该新公理独立于 `T`，并证明其与 `T` 是相对一致的。

#### **3.1 新公理的引入**

我们考虑以下 `L`-公式，并将其命名为公理 A12：

**公理 A12:** `∀x∀y∀z ((P(x,y) ∧ P(x,z)) → P(x, f(y,z)))`

我们将证明 `T ⊬ A12` 且 `T ⊬ ¬A12`，从而确立 A12 相对于 `T` 的独立性。

#### **3.2 独立性证明**

独立性的证明包含两个部分：
1.  构建一个 `T` 的模型，其中 `A12` 为假。
2.  构建一个 `T` 的模型，其中 `A12` 为真。

**命题 3.2.1**. `T ⊬ A12`.

**证明**.
为证明此命题，我们只需指出在第二节中构建的模型 `M`（为清晰起见，此处称其为 `M_Z2`）是 `T` 的一个模型，但不是 `A12` 的模型。
1.  在定理 2.2.4 中，我们已证明 `M_Z2 ⊨ T`。
2.  我们现在证明 `M_Z2 <binary data, 2 bytes> A12`。
    *   根据语义，我们需要找到一个变量赋值 `s: V → U = ℕ`，使得 `M_Z2, s <binary data, 2 bytes> (P(x,y) ∧ P(x,z)) → P(x, f(y,z))`。
    *   令 `s(x) = 1`, `s(y) = 1`, `s(z) = 1`。
    *   **评估前件 (Antecedent):**
        *   `M_Z2, s ⊨ P(x,y)` 当且仅当 `s(x) ≡ s(y) (mod 2)`，即 `1 ≡ 1 (mod 2)`，此为真。
        *   `M_Z2, s ⊨ P(x,z)` 当且仅当 `s(x) ≡ s(z) (mod 2)`，即 `1 ≡ 1 (mod 2)`，此为真。
        *   因此，`M_Z2, s ⊨ P(x,y) ∧ P(x,z)`。
    *   **评估后件 (Consequent):**
        *   `M_Z2, s ⊨ P(x, f(y,z))` 当且仅当 `s(x) ≡ f^M(s(y), s(z)) (mod 2)`。
        *   `f^M(s(y), s(z)) = f^M(1, 1) = 1 + 1 = 2`。
        *   该断言变为 `1 ≡ 2 (mod 2)`，此为假。
    *   由于在此赋值下，蕴含式的前件为真而后件为假，故该蕴含式为假。
    *   因此，`M_Z2 <binary data, 2 bytes> ∀x∀y∀z ((P(x,y) ∧ P(x,z)) → P(x, f(y,z)))`。
3.  根据一阶逻辑的可靠性定理 (推论 2.3.2)，如果 `T ⊢ A12`，那么 `T` 的所有模型都必须满足 `A12`。由于我们找到了 `T` 的一个模型 `M_Z2` 不满足 `A12`，故 `T ⊬ A12`。

**命题 3.2.2**. `T ⊬ ¬A12`.

**证明**.
为证明此命题，我们需要构建理论 `T ∪ {A12}` 的一个模型。若该理论有模型，则它是一致的，从而 `T` 不能证明 `¬A12`。

##### **3.2.2.1 新模型 `M_S3` 的构建**

**定义 3.2.2.1 (模型 `M_S3`)**.
我们定义一个 `L`-结构 `M_S3 = <U, f^M, P^M>`，其各组成部分如下：

1.  **论域 (Universe):** `U` 是自然数集 `ℕ = {0, 1, 2, ...}`。

2.  **函数解释 (Interpretation of `f`):** `f^M` 定义如下：
    *   `f^M: U × U → U`
    *   对于任意 `n₁, n₂ ∈ U`，`f^M(n₁, n₂) := (-(n₁ + n₂)) mod 3`。
    *   其中 `k mod 3` 表示 `k` 除以 3 的最小非负余数，结果在 `{0, 1, 2}` 中。

3.  **谓词解释 (Interpretation of `P`):** `P^M` 是 `U` 上的二元关系“同余模 3”。
    *   `P^M ⊆ U × U`
    *   对于任意 `n₁, n₂ ∈ U`，`<n₁, n₂> ∈ P^M` 当且仅当 `n₁ ≡ n₂ (mod 3)`。

4.  **等词解释 (Interpretation of ` = `)**: 解释为 `U` 上的恒等关系。

##### **3.2.2.2 `M_S3` 的模型验证**

**引理 3.2.2.2**. `M_S3` 是 `T` 的一个模型，即 `M_S3 ⊨ T`。

**证明**.
我们需要逐一验证 `T` 的非逻辑公理在 `M_S3` 中为真。令 `s` 为任意赋值函数，`s(v) = n_v`。

1.  **验证 `M_S3 ⊨ Axiom T1`**: `∀x∀y∀z (P(f(x,y), z) ⇔ P(x, f(y,z)))`
    *   `M_S3, s ⊨ P(f(x,y), z)`
        ⇔ `f^M(n_x, n_y) ≡ n_z (mod 3)`
        ⇔ `(-(n_x + n_y)) mod 3 ≡ n_z (mod 3)`
        ⇔ `-(n_x + n_y) ≡ n_z (mod 3)`
        ⇔ `n_x + n_y ≡ -n_z (mod 3)`
        ⇔ `n_x ≡ -n_y - n_z (mod 3)`
        ⇔ `n_x ≡ -(n_y + n_z) (mod 3)`
    *   `M_S3, s ⊨ P(x, f(y,z))`
        ⇔ `n_x ≡ f^M(n_y, n_z) (mod 3)`
        ⇔ `n_x ≡ (-(n_y + n_z)) mod 3 (mod 3)`
        ⇔ `n_x ≡ -(n_y + n_z) (mod 3)`
    *   由于两个表达式等价于同一个同余式，故该双向蕴含成立。公理 T1 在 `M_S3` 中为真。

2.  **验证 `M_S3 ⊨ Axiom T2`**: `∀x∀y∀a (P(a, f(x,y)) ⇔ P(a, f(y,x)))`
    *   `M_S3, s ⊨ P(a, f(x,y))` ⇔ `n_a ≡ f^M(n_x, n_y) (mod 3)`。
    *   `M_S3, s ⊨ P(a, f(y,x))` ⇔ `n_a ≡ f^M(n_y, n_x) (mod 3)`。
    *   由于 `f^M(n_x, n_y) = (-(n_x + n_y)) mod 3` 且 `f^M(n_y, n_x) = (-(n_y + n_x)) mod 3`，而整数加法是交换的，`n_x+n_y = n_y+n_x`，因此 `f^M(n_x, n_y) = f^M(n_y, n_x)`。
    *   故两个同余式等价。公理 T2 在 `M_S3` 中为真。

3.  **验证 `M_S3 ⊨ Axiom T3`**: `∀y∀z ((∀a∀x (P(a,f(x,y)) ⇔ P(a,f(x,z)))) → (P(y,z) ∧ P(z,y)))`
    *   假设蕴含式的前件为真。即，对于任意 `n_a, n_x ∈ ℕ`，`n_a ≡ f^M(n_x, n_y) (mod 3) ⇔ n_a ≡ f^M(n_x, n_z) (mod 3)` 成立。
    *   根据同余关系的性质，这蕴含了对于任意 `n_x ∈ ℕ`，`f^M(n_x, n_y) ≡ f^M(n_x, n_z) (mod 3)`。
    *   展开 `f^M` 的定义：`(-(n_x + n_y)) mod 3 ≡ (-(n_x + n_z)) mod 3 (mod 3)`。
    *   这等价于 `-(n_x + n_y) ≡ -(n_x + n_z) (mod 3)`。
    *   两边同乘以 -1：`n_x + n_y ≡ n_x + n_z (mod 3)`。
    *   根据模算术的加法消除律，可得 `n_y ≡ n_z (mod 3)`。
    *   这正是 `M_S3, s ⊨ P(y,z)`。
    *   由于同余关系是对称的，`n_z ≡ n_y (mod 3)` 也成立，即 `M_S3, s ⊨ P(z,y)`。
    *   因此 `M_S3, s ⊨ P(y,z) ∧ P(z,y)`。
    *   我们证明了从前件的真可以推导出后件的真，故公理 T3 在 `M_S3` 中为真。

综上所述，`M_S3` 满足 `T` 的所有非逻辑公理，故 `M_S3 ⊨ T`。

**引理 3.2.2.3**. `M_S3` 是 `A12` 的一个模型，即 `M_S3 ⊨ A12`。

**证明**.
我们需要证明 `M_S3 ⊨ ∀x∀y∀z ((P(x,y) ∧ P(x,z)) → P(x, f(y,z)))`。
1.  令 `s` 为任意赋值函数，`s(x)=n_x, s(y)=n_y, s(z)=n_z`。
2.  假设蕴含式的前件 `P(x,y) ∧ P(x,z)` 在 `M_S3, s` 下为真。
    *   这意味着 `M_S3, s ⊨ P(x,y)` 且 `M_S3, s ⊨ P(x,z)`。
    *   根据 `P^M` 的定义，即 `n_x ≡ n_y (mod 3)` 且 `n_x ≡ n_z (mod 3)`。
3.  我们需要证明在此假设下，后件 `P(x, f(y,z))` 亦为真。
    *   后件断言 `n_x ≡ f^M(n_y, n_z) (mod 3)`。
    *   即 `n_x ≡ (-(n_y + n_z)) mod 3 (mod 3)`，等价于 `n_x ≡ -(n_y + n_z) (mod 3)`。
4.  利用前件的假设：由于 `n_y ≡ n_x (mod 3)` 且 `n_z ≡ n_x (mod 3)`，我们可以将同余式 `-(n_y + n_z)` 中的 `n_y` 和 `n_z` 替换为 `n_x`。
    *   `-(n_y + n_z) ≡ -(n_x + n_x) (mod 3)`
    *   `-(n_y + n_z) ≡ -2n_x (mod 3)`
5.  因此，我们需要验证 `n_x ≡ -2n_x (mod 3)` 是否恒成立。
    *   该同余式等价于 `3n_x ≡ 0 (mod 3)`。
    *   对于任何整数 `n_x`，`3n_x` 总是 3 的倍数，因此 `3n_x ≡ 0 (mod 3)` 恒为真。
6.  由此，我们证明了从前件的真可以推导出后件的真。故 `A12` 在 `M_S3` 中为真。

**完成命题 3.2.2 的证明**:
由引理 3.2.2.2 和 3.2.2.3 可知，`M_S3` 是理论 `T' = T ∪ {A12}` 的一个模型。根据一阶逻辑的可靠性定理，任何有模型的理论都是一致的。因此，`T'` 是一致的。如果 `T ⊢ ¬A12`，那么 `T'` 将能证明 `A12` 和 `¬A12`，从而导致不一致。这与我们刚得出的结论矛盾。因此，`T ⊬ ¬A12`。

#### **3.3 结论**

**定理 3.3.1 (A12 的相对一致性)**.
理论 `T' = T ∪ {A12}` 是一致的。
**证明**. 如命题 3.2.2 的证明所示，理论 `T'` 拥有模型 `M_S3`，因此它是一致的。

**定理 3.3.2 (A12 的独立性)**.
公理 `A12` 独立于理论 `T`。
**证明**.
1.  由命题 3.2.1，`T ⊬ A12`。
2.  由命题 3.2.2，`T ⊬ ¬A12`。
3.  根据独立性的定义，公理 `A12` 独立于理论 `T`。