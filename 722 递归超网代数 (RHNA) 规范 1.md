## 1. 形式句法 (Formal Syntax)

我们定义一种语言 $\mathcal{L}$，为了清晰区分不同层级的对象，我们将句法分为**项 (Terms)** 和 **表达式 (Expressions)**。

### 1.1 句法范畴 (Syntactic Categories)
*   $x \in \mathcal{V}$: 变量/原子标识符。
*   $\tau \in \mathcal{T}$: **项 (Terms)** 。
*   $\phi \in \mathcal{F}$: **表达式 (Graphs)**。

### 1.2 抽象语法 (Abstract Syntax)
使用扩展的 BNF 范式定义：

$$
\begin{aligned}
\text{(Term)} \quad \tau &::= x  \\
& \quad \mid \ \{ \tau_1, \dots, \tau_n \} \\
& \quad \mid \ \lfloor \tau_i \xrightarrow{\phi} \tau_j \rfloor \\
& \quad \mid \ \lceil \phi \rceil  \\
\\
\text{(Formula)} \quad \phi &::= \varnothing \\
& \quad \mid \ \tau_i \to \tau_j \\
& \quad \mid \ \phi_1 + \phi_2 
\end{aligned}
$$



## 2. 形式语义 (Formal Semantics)

为了赋予算子 $\lfloor \tau_i \xrightarrow{\phi} \tau_j \rfloor$ 以“证据（Evidence）”的本体论地位，我们采用**基于实现的语义 (Realizability Semantics)**。在此框架下，表达式 $\phi$ 指称一个**二元证据关系**，而项 $\tau$ 指称语义域中的**对象**。特别是，$\lfloor \dots \rfloor$ 算子将生成一个具体的、可被检验的证据对象（Evidence Object）。

### 2.1 语义域 (Semantic Domains)

设 $\mathcal{M}$ 为解释模型。我们需要构造一个满足递归方程的语义全域 $\mathbb{D}$。

定义 $\mathbb{D}$ 为满足下列同构关系的最小解（利用 Scott 域或非良基集合论）：

$$
\mathbb{D} \cong \mathcal{A} \oplus \mathcal{P}_{\text{fin}}(\mathbb{D}) \oplus \mathbb{E} \oplus \mathbb{C}
$$

其中：
*   $\mathcal{A}$: **原子值**集合（对应变量的解释）。
*   $\mathcal{P}_{\text{fin}}(\mathbb{D})$: **有限集**空间（对应集合项）。
*   $\mathbb{E} = \mathbb{D} \times \mathbb{C} \times \mathbb{D}$: **证据对象**空间。一个证据 $e \in \mathbb{E}$ 是一个三元组 $\langle u, c, v \rangle$，表示“依据规则代码 $c$，从 $u$ 到 $v$ 的证明”。
*   $\mathbb{C}$: **句法代码**空间（对应 $\phi$ 的引用/哥德尔数），用于实现反射性。

### 2.2 赋值与解释函数 (Valuation and Interpretation)

给定变量赋值函数 $g: \mathcal{V} \to \mathbb{D}$。我们定义两个互递归的语义函数：
1.  **项解释 (Term Valuation)**: $⟦ \cdot ⟧_g : \mathcal{T} \to \mathbb{D}$
2.  **表达式实现 (Expression Realization)**: $\mathcal{R}_g(\cdot) : \mathcal{F} \to \mathcal{P}(\mathbb{D} \times \mathbb{D})$

#### 2.2.1 表达式的语义：可达关系
表达式 $\phi$ 的语义不仅是真值，而是语义域中对象对的集合，表示允许的转换路径。

$$
\begin{aligned}
\mathcal{R}_g(\varnothing) &= \emptyset \\
\mathcal{R}_g(\tau_i \to \tau_j) &= \{ (⟦ \tau_i ⟧_g, ⟦ \tau_j ⟧_g) \} \\
\mathcal{R}_g(\phi_1 + \phi_2) &= \mathcal{R}_g(\phi_1) \cup \mathcal{R}_g(\phi_2)
\end{aligned}
$$

#### 2.2.2 项的语义：对象构造
项的语义将句法结构映射为域 $\mathbb{D}$ 中的实体。

$$
\begin{aligned}
⟦ x ⟧_g &= g(x) \\
⟦ \{ \tau_1, \dots, \tau_n \} ⟧_g &= \{ ⟦ \tau_1 ⟧_g, \dots, ⟦ \tau_n ⟧_g \} \\
⟦ \lceil \phi \rceil ⟧_g &= \text{code}(\phi) \quad (\in \mathbb{C}) \\
⟦ \lfloor \tau_i \xrightarrow{\phi} \tau_j \rfloor ⟧_g &= \mathbf{ev}(⟦ \tau_i ⟧_g, \text{code}(\phi), ⟦ \tau_j ⟧_g)
\end{aligned}
$$

其中，$\mathbf{ev}: \mathbb{D} \times \mathbb{C} \times \mathbb{D} \to \mathbb{E}$ 是域 $\mathbb{D}$ 中的构造函数，它将起点、规则代码和终点**打包（Reify）**为一个第一类（First-class）证据对象。

---

### 2.3 证据有效性判定 (Judgement of Evidential Validity)

**定义 2.3.1 (有效证据)**
称一个项 $t = \lfloor \tau_i \xrightarrow{\phi} \tau_j \rfloor$ 在模型 $\mathcal{M}$ 和赋值 $g$ 下是**有效的 (Valid)**，当且仅当该项所指称的转换关系确实存在于表达式 $\phi$ 的实现集合中。

形式化表示为：
$$
\mathcal{M}, g \vDash \lfloor \tau_i \xrightarrow{\phi} \tau_j \rfloor \iff (⟦ \tau_i ⟧_g, ⟦ \tau_j ⟧_g) \in \mathcal{R}_g(\phi)
$$

