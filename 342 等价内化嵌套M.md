# **等价内化嵌套系统M**

### **1. 语法 (Syntax)**

**1.1. 函数 (Functions)**

*   `·`：一个二元函数，表示**应用**。记为 `(· a b)`。
*   `equiv`：一个二元函数，表示**等价**。记为 `(equiv a b)`。

**1.2. 常量 (Constants)**

*   `T`：一个零元函数（原子项），代表**已证实的等价性**或**真理**。
*   `F`：一个零元函数（原子项）。

**1.3. 项 (Terms)**

项的集合由以下规则递归定义：
1.  `T` 是项。
2.  `F` 是项。
3.  若 `a` 和 `b` 是项，则 `(· a b)` 是项。
4.  若 `a` 和 `b` 是项，则 `(equiv a b)` 是项。

**1.4. 公式 (Formulas)**

公式的集合如下构成：
1. 若 `a` 和 `b` 是项，则  `a = b`是公式。
### **2. 证明论**

对于任意项 `a`, `b`, `c`, `d`, `f`, `x`：

**核心交互公理模式**

*   **A1: 左侧穿越 (Left Passage)**
    `(· x (equiv a b)) = (equiv (· b x) a)`

*   **A2: 右侧穿越 (Right Passage)**
    `(· (equiv a b) x) = (equiv b (· a x))`


**外化规则**

*    **A3: 外化规则**
```
	若 ⊢ (equiv a b) = T
	-------------------- (A3)
	则 ⊢ a = b
```

*   **A4: 内化规则**
```
	若 ⊢ a = b
	-------------------- (A4)
	则 ⊢ (equiv a b) = T
```

**背景等式逻辑 (Background Equational Logic)**

证明关系 `⊢` 由公理模式和推理规则归纳定义。以下结构性规则是 `⊢` 定义的一部分，它们共同确保了 ` = ` 作为一个全等关系 (congruence relation) 的性质。因此，`⊢` 满足等式逻辑并非一个外部假设，而是其定义的直接结果。对于任意项 `a`, `b`, `c`：

**公理模式：**
*   `Refl: a = a`

**推理规则：**
*   `Symm: a = b / b = a` (若 `⊢ a = b` 则 `⊢ b = a`)
*   `Trans: a = b, b = c / a = c`
*   `Cong-·: a = b / (· a c) = (· b c)` and `a = b / (· c a) = (· c b)`
*   `Cong-equiv: a = b / (equiv a c) = (equiv b c)` and `a = b / (equiv c a) = (equiv c b)`
`

---

### **3. 模型论语义 (Model-Theoretic Semantics)**

#### **3.1. 模型 M 的构造**

**3.1.1. 定义**

我们构造一个模型 M，其组成为 `⟨D, I⟩`，其中：

*   **a) 定义域 (Domain):** `D = {0, 1}`。

*   **b) 解释 (Interpretation) I:**
    *   `I(T) = 1`
    *   `I(F) = 0`
    *   `I(·)` 是一个二元函数 `·^M : D × D → D`，定义为：
        `a ·^M b = (a + b) mod 2`
    *   `I(equiv)` 是一个二元函数 `equiv^M : D × D → D`，定义为：
        `a equiv^M b = (1 + a + b) mod 2`

**3.1.2. 语义规则**

*   **a) 项的赋值 (Valuation):** 对于任意项 `t`，其在模型 M 中的赋值 `t^M` 定义如下：
    1.  `T^M = I(T) = 1`
    2.  `F^M = I(F) = 0`
    3.  对于项 `(· a b)`，`(· a b)^M = a^M ·^M b^M`
    4.  对于项 `(equiv a b)`，`(equiv a b)^M = a^M equiv^M b^M`

*   **b) 公式的满足 (Satisfaction):** 模型 M 满足一个公式 `a = b`，记为 `M ⊨ a = b`，当且仅当 `a^M = b^M`。

**3.1.3. 公理验证**

令 `x, a, b` 为 `D` 中的任意元素，代表对应项的任意赋值。

*   **验证 A1: `(· x (equiv a b)) = (equiv (· b x) a)`**
    *   左侧 (LHS):
        `(· x (equiv a b))^M = x^M ·^M (equiv a b)^M`
        ` = x ·^M (a^M equiv^M b^M)`
        ` = x + (1 + a + b) (mod 2)`
    *   右侧 (RHS):
        `(equiv (· b x) a)^M = (· b x)^M equiv^M a^M`
        ` = (b^M ·^M x^M) equiv^M a^M`
        ` = (b + x) equiv^M a`
        ` = 1 + (b + x) + a (mod 2)`
    *   由于模2加法的交换律和结合律，`x + 1 + a + b = 1 + b + x + a (mod 2)`。因此 LHS = RHS。故 `M ⊨ A1`。

*   **验证 A2: `(· (equiv a b) x) = (equiv b (· a x))`**
    *   左侧 (LHS):
        `(· (equiv a b) x)^M = (equiv a b)^M ·^M x^M`
        ` = (a^M equiv^M b^M) ·^M x^M`
        ` = (1 + a + b) + x (mod 2)`
    *   右侧 (RHS):
        `(equiv b (· a x))^M = b^M equiv^M (· a x)^M`
        ` = b^M equiv^M (a^M ·^M x^M)`
        ` = b equiv^M (a + x)`
        ` = 1 + b + (a + x) (mod 2)`
    *   由于模2加法的交换律和结合律，`1 + a + b + x = 1 + b + a + x (mod 2)`。因此 LHS = RHS。故 `M ⊨ A2`。

#### **3.2. 可靠性定理 (Soundness Theorem)**

**3.2.1. 定理**
若 `⊢ a = b`，则 `M ⊨ a = b`。

**3.2.2. 证明**
通过对证明 `⊢ a = b` 的结构进行归纳。

*   **基础情况 (Base Cases): 公理**
    *   `A1`, `A2`: 已在 3.1.3 节中验证在 M 中为真。
    *   `Refl: a = a`: `M ⊨ a = a` 因为 `a^M = a^M` 根据等号的自反性在 `D` 中恒成立。

*   **归纳步骤 (Inductive Steps): 推理规则**
    假设所有前提在模型 M 中都为真，我们需要证明结论也为真。

    *   `Symm: a = b / b = a`
        假设 `M ⊨ a = b`，即 `a^M = b^M`。根据 `D` 中等号的对称性，`b^M = a^M`。因此 `M ⊨ b = a`。

    *   `Trans: a = b, b = c / a = c`
        假设 `M ⊨ a = b` 且 `M ⊨ b = c`，即 `a^M = b^M` 且 `b^M = c^M`。根据 `D` 中等号的传递性，`a^M = c^M`。因此 `M ⊨ a = c`。

    *   `Cong-·: a = b / (· a c) = (· b c)`
        假设 `M ⊨ a = b`，即 `a^M = b^M`。则 `(· a c)^M = a^M ·^M c^M`。由于 `·^M` 是一个函数，`a^M = b^M` 蕴含 `a^M ·^M c^M = b^M ·^M c^M`。后者等于 `(· b c)^M`。因此 `M ⊨ (· a c) = (· b c)`。对于 `(· c a) = (· c b)` 同理。

    *   `Cong-equiv: a = b / (equiv a c) = (equiv b c)`
        假设 `M ⊨ a = b`，即 `a^M = b^M`。则 `(equiv a c)^M = a^M equiv^M c^M`。由于 `equiv^M` 是一个函数，`a^M = b^M` 蕴含 `a^M equiv^M c^M = b^M equiv^M c^M`。后者等于 `(equiv b c)^M`。因此 `M ⊨ (equiv a c) = (equiv b c)`。对于 `(equiv c a) = (equiv c b)` 同理。

    *   `A3 (外化): (equiv a b) = T / a = b`
        假设 `M ⊨ (equiv a b) = T`，即 `(equiv a b)^M = T^M`。根据定义，这等价于 `a^M equiv^M b^M = 1`。根据 `equiv^M` 的定义，`1 + a^M + b^M = 1 (mod 2)`，这当且仅当 `a^M + b^M = 0 (mod 2)`，即 `a^M = b^M`。因此 `M ⊨ a = b`。

    *   `A4 (内化): a = b / (equiv a b) = T`
        假设 `M ⊨ a = b`，即 `a^M = b^M`。根据 `equiv^M` 的定义，`a^M equiv^M b^M = (1 + a^M + b^M) mod 2`。因为 `a^M = b^M`，所以 `a^M + b^M = 2a^M = 0 (mod 2)`。因此 `a^M equiv^M b^M = 1`。这等价于 `(equiv a b)^M = 1`。由于 `T^M = 1`，我们有 `(equiv a b)^M = T^M`。因此 `M ⊨ (equiv a b) = T`。

由于所有公理在 M 中为真，且所有推理规则均保持满足性，根据对证明长度的归纳，定理得证。∎

#### **3.3. 非平凡一致性定理 (Non-trivial Consistency Theorem)**

**3.3.1. 定理**
系统 M 是一致的，特别地，`⊬ T = F`。

**3.3.2. 证明**
采用反证法。

1.  假设 `⊢ T = F`。
2.  根据定理 3.2.1 (可靠性)，若 `⊢ T = F`，则 `M ⊨ T = F`。
3.  根据满足性的定义，`M ⊨ T = F` 蕴含 `T^M = F^M`。
4.  根据模型定义 3.1.1，`T^M = 1` 且 `F^M = 0`。
5.  因此，可推得 `1 = 0`。
6.  这在定义域 `D = {0, 1}` 中是一个矛盾。

此矛盾表明初始假设错误。故 `⊬ T = F`。∎

---

### **4. 系统定理 (System Theorems)**

#### **定理 4.1: `equiv` 的内部自反性 (Internal Reflexivity of `equiv`)**

**定理陈述:**
对于任意项 `a`，`⊢ (equiv a a) = T`。

**证明:**

| 步骤 | 公式 | 理由 |
| :--- | :--- | :--- |
| 1. | `a = a` | 公理 `Refl` |
| 2. | `(equiv a a) = T` | 规则 `A4` (内化)，应用于步骤 1 |

∎

---

#### **定理 4.2: 双重应用吸收律 (Double Application Absorption Law)**

**定理陈述:**
对于任意项 `a, b, x, y`，`⊢ (· y (· x (equiv a b))) = (equiv (· a y) (· b x))`。

**证明:**

| 步骤 | 公式 | 理由 |
| :--- | :--- | :--- |
| 1. | `(· x (equiv a b)) = (equiv (· b x) a)` | 公理 `A1` |
| 2. | `(· y (· x (equiv a b))) = (· y (equiv (· b x) a))` | 规则 `Cong-·`，应用于步骤 1 |
| 3. | `(· y (equiv (· b x) a)) = (equiv (· a y) (· b x))` | 公理 `A1`，其中 `x` 替换为 `y`，`a` 替换为 `(· b x)`，`b` 替换为 `a` |
| 4. | `(· y (· x (equiv a b))) = (equiv (· a y) (· b x))` | 规则 `Trans` (传递性)，应用于步骤 2 和步骤 3 |

∎

---

#### **定理 4.3: `·` 在 `equiv` 上的右分配律 (Right Distributive Law of `·` over `equiv`)**

**定理陈述:**
对于任意项 `a, b, x`，`⊢ (· x (· x (equiv a b))) = (equiv (· a x) (· b x))`。

**证明:**

| 步骤 | 公式 | 理由 |
| :--- | :--- | :--- |
| 1. | `(· y (· x (equiv a b))) = (equiv (· a y) (· b x))` | 定理 4.2 |
| 2. | `(· x (· x (equiv a b))) = (equiv (· a x) (· b x))` | 在步骤 1 的公式中进行代入 `y := x` |

∎

---

#### **定理 4.4: `T` 应用的等价表达 (Equivalent Expression of `T` Application)**

**定理陈述:**
对于任意项 `a`，`⊢ (· T a) = (equiv T (· T a))`。

**证明:**

| 步骤 | 公式 | 理由 |
| :--- | :--- | :--- |
| 1. | `(· (equiv T T) a) = (equiv T (· T a))` | 公理 `A2`，其中 `a` 替换为 `T`，`b` 替换为 `T`，`x` 替换为 `a` |
| 2. | `(equiv T T) = T` | 定理 4.1，其中 `a` 替换为 `T` |
| 3. | `(· T a) = (· (equiv T T) a)` | 规则 `Cong-·` 应用于步骤 2，后接 `Symm` |
| 4. | `(· T a) = (equiv T (· T a))` | 规则 `Trans`，应用于步骤 3 和步骤 1 |

∎

---

#### **定理 4.5: `T` 应用的特殊对合性 (Special Involution for `T` Application)**

**定理陈述:**
对于任意项 `a`，`⊢ (· T a) = (equiv T (equiv T (· T a)))`。

**证明:**

| 步骤 | 公式 | 理由 |
| :--- | :--- | :--- |
| 1. | `(· T a) = (equiv T (· T a))` | 定理 4.4 |
| 2. | `(equiv T (· T a)) = (equiv T (equiv T (· T a)))` | 规则 `Cong-equiv`，应用于步骤 1 |
| 3. | `(· T a) = (equiv T (equiv T (· T a)))` | 规则 `Trans`，应用于步骤 1 和步骤 2 |

∎