# **等价嵌套证明系统M**

### **1. 语法 (Syntax)**

**1.1. 函数 (Functions)**

*   `·`：一个二元函数，表示**应用**。记为 `(· a b)`。
*   `equiv`：一个二元函数，表示**等价**。记为 `(equiv a b)`。

**1.2. 常量 (Constants)**

*   `T`：一个零元函数（原子项），代表**已证实的等价性**或**真理**。
*   `F`：一个零元函数（原子项）。

**1.3. 项 (Terms)**

项的集合由以下规则递归定义：
1.  `T` 是项。
2.  `F` 是项。
3.  若 `a` 和 `b` 是项，则 `(· a b)` 是项。
4.  若 `a` 和 `b` 是项，则 `(equiv a b)` 是项。

**1.4. 公式 (Formulas)**

公式的集合如下构成：
1. 若 `a` 和 `b` 是项，则  `a = b`是公式。
### **2. 证明论**

对于任意项 `a`, `b`, `c`, `d`, `f`, `x`：

**核心交互公理模式**

*   **A1: 右动作 (Right Action)**
    `(· (equiv a b) b) = (equiv a (· a b))`

*   **A2: 左动作 (Left Action)**
    `(· a (equiv a b)) = (equiv b (· a b))`


**外化规则**

*    **A3: 外化规则**
```
	若 ⊢ (equiv a b) = T
	-------------------- (A3)
	则 ⊢ a = b
```

*   **A4: 内化规则**
```
	若 ⊢ a = b
	-------------------- (A4)
	则 ⊢ (equiv a b) = T
```

**背景等式逻辑 (Background Equational Logic)**

证明关系 `⊢` 由公理模式和推理规则归纳定义。以下结构性规则是 `⊢` 定义的一部分，它们共同确保了 ` = ` 作为一个全等关系 (congruence relation) 的性质。因此，`⊢` 满足等式逻辑并非一个外部假设，而是其定义的直接结果。对于任意项 `a`, `b`, `c`：

**公理模式：**
*   `Refl: a = a`

**推理规则：**
*   `Symm: a = b / b = a` (若 `⊢ a = b` 则 `⊢ b = a`)
*   `Trans: a = b, b = c / a = c`
*   `Cong-·: a = b / (· a c) = (· b c)` and `a = b / (· c a) = (· c b)`
*   `Cong-equiv: a = b / (equiv a c) = (equiv b c)` and `a = b / (equiv c a) = (equiv c b)`
`

#### **2.1 替换引理 (Substitution Lemma)**

**定义 2.1.1 (项语境与填充)**
一个**项语境** (term context) `C[·]` 是一个带有一个唯一“空位” `[·]` 的项。我们通过以下归纳规则定义语境的集合：
1.  `[·]` 本身是一个语境 (空语境)。
2.  若 `C[·]` 是一个语境且 `d` 是一个项，则 `(· C[·] d)` 和 `(· d C[·])` 是语境。
3.  若 `C[·]` 是一个语境且 `d` 是一个项，则 `(equiv C[·] d)` 和 `(equiv d C[·])` 是语境。

**填充**操作 `C[a]` 指将语境 `C[·]` 中的空位 `[·]` 替换为项 `a` 所得到的项。

**引理 2.1 (替换引理 - Substitution Lemma)**

若 `⊢ (equiv a b) = T`，则对于任何一元项语境 (unary term context) `C[·]`，我们有 `⊢ (equiv C[a] C[b]) = T`。

**证明：**

本引理的证明采用对语境 `C[·]` 的结构进行归纳的方法。

**1. 预备步骤：外化假设**
   1. `⊢ (equiv a b) = T`  (引理的假设)
   2. `⊢ a = b`  (根据步骤 1 和 **A3: 外化规则**)

   现在我们的目标是证明，在 `⊢ a = b` 的前提下，对于任何语境 `C[·]`，都有 `⊢ C[a] = C[b]`。一旦证明了这一点，我们就可以通过 **A4: 内化规则** 得到最终结论 `⊢ (equiv C[a] C[b]) = T`。

**2. 归纳基础 (Base Case)**
   当语境 `C[·]` 是最简单的语境，即 `C[·] = [·]` (空语境) 时：
   1. `C[a]` 等同于 `a`。
   2. `C[b]` 等同于 `b`。
   3. 我们需要证明 `⊢ a = b`。
   4. 这在 **预备步骤** 的第 2 步已经得出。
   5. 因此，基础情况成立。

**3. 归纳步骤 (Inductive Step)**
   假设对于语境 `C'[·]` 和 `C''[·]`，该属性成立。即，若 `⊢ a = b`，则 `⊢ C'[a] = C'[b]` 且 `⊢ C''[a] = C''[b]` (此为**归纳假设**)。
   我们必须证明对于由这些语境构造的更复杂的语境，该属性也成立。项的构造规则有两种 (`·` 和 `equiv`)，因此我们有四种情况需要考虑：

   **情况 (i):** `C[·] = (· C'[·] d)`，其中 `d` 是任意项。
   1. `C[a] = (· C'[a] d)`。
   2. `C[b] = (· C'[b] d)`。
   3. 根据归纳假设，我们有 `⊢ C'[a] = C'[b]`。
   4. 根据背景等式逻辑的**合同性规则 (Cong-·)** `x = y / (· x z) = (· y z)`，将此规则应用于 `C'[a] = C'[b]`，可得：
      `⊢ (· C'[a] d) = (· C'[b] d)`。
   5. 这正是 `⊢ C[a] = C[b]`。因此，此情况成立。

   **情况 (ii):** `C[·] = (· d C'[·])`，其中 `d` 是任意项。
   6. `C[a] = (· d C'[a])`。
   7. `C[b] = (· d C'[b])`。
   8. 根据归纳假设，我们有 `⊢ C'[a] = C'[b]`。
   9. 根据背景等式逻辑的**合同性规则 (Cong-·)** `x = y / (· z x) = (· z y)`，可得：
      `⊢ (· d C'[a]) = (· d C'[b])`。
   10. 这正是 `⊢ C[a] = C[b]`。因此，此情况成立。

   **情况 (iii):** `C[·] = (equiv C'[·] d)`，其中 `d` 是任意项。
   11. `C[a] = (equiv C'[a] d)`。
   12. `C[b] = (equiv C'[b] d)`。
   13. 根据归纳假设，我们有 `⊢ C'[a] = C'[b]`。
   14. 根据背景等式逻辑的**合同性规则 (Cong-equiv)** `x = y / (equiv x z) = (equiv y z)`，可得：
      `⊢ (equiv C'[a] d) = (equiv C'[b] d)`。
   15. 这正是 `⊢ C[a] = C[b]`。因此，此情况成立。

   **情况 (iv):** `C[·] = (equiv d C'[·])`，其中 `d` 是任意项。
   16. `C[a] = (equiv d C'[a])`。
   17. `C[b] = (equiv d C'[b])`。
   18. 根据归纳假设，我们有 `⊢ C'[a] = C'[b]`。
   19. 根据背景等式逻辑的**合同性规则 (Cong-equiv)** `x = y / (equiv z x) = (equiv z y)`，可得：
      `⊢ (equiv d C'[a]) = (equiv d C'[b])`。
   20. 这正是 `⊢ C[a] = C[b]`。因此，此情况成立。

**4. 结论**
   通过对 `C[·]` 的结构归纳，我们证明了若 `⊢ a = b`，则对于任意语境 `C[·]`，`⊢ C[a] = C[b]` 恒成立。

   1. `⊢ C[a] = C[b]` (如上所示)
   2. `⊢ (equiv C[a] C[b]) = T` (根据步骤 1 和 **A4: 内化规则**)

引理 2.1 证毕。∎

---

### **3. 操作语义 (Operational Semantics)**

#### 3.1 操作语义

为了分析系统 M 的计算行为，我们将其核心公理 A1 和 A2 解释为一个有向的项重写系统 (Term Rewriting System, TRS)。该系统定义了项如何通过计算进行化简。

##### **定义 3.1 (重写系统 R)**
项重写系统 `R` 由以下两个重写规则模式组成，对任意项 `a`, `b` 成立：
*   **R1**: `(· (equiv a b) b) → (equiv a (· a b))`
*   **R2**: `(· a (equiv a b)) → (equiv b (· a b))`

##### **定义 3.2 (重写关系)**
1.  **一步重写 (One-Step Reduction)**: 我们称项 `t` 可以一步重写为项 `s`，记作 `t → s`。该关系 `→` 是由以下规则归纳定义的最小关系：
    *   **基础规则 (Axiom Rules):**
        *   对于任意项 `a, b`，有 `(· (equiv a b) b) → (equiv a (· a b))` (规则 R1)。
        *   对于任意项 `a, b`，有 `(· a (equiv a b)) → (equiv b (· a b))` (规则 R2)。
    *   **合同性规则 (Congruence Rules):**
        *   若 `t → s`，则对于任意项 `c`，有 `(· t c) → (· s c)`。
        *   若 `t → s`，则对于任意项 `c`，有 `(· c t) → (· c s)`。
        *   若 `t → s`，则对于任意项 `c`，有 `(equiv t c) → (equiv s c)`。
        *   若 `t → s`，则对于任意项 `c`，有 `(equiv c t) → (equiv c s)`。
    此定义将合同性直接构建到了一步重写关系 `→` 的定义中，确保了重写可以在任何项语境下发生。

2.  **重写序列 (Reduction Sequence)**: `t →* s` 表示 `t` 可以通过零步或多步重写得到 `s`。它是 `→` 关系的自反传递闭包。
3.  **可约项 (Reducible Term / Redex)**: 一个项 `t` 如果可以被重写 (即存在 `s` 使得 `t → s`)，则称 `t` 是可约的。匹配规则 R1 或 R2 左部的子项被称为可约式 (redex)。
4.  **正规形式 (Normal Form)**: 一个项 `t` 如果不可再被重写，则称 `t` 处于**正规形式**。

在背景等式逻辑下，系统 M 中的可证等式 `M ⊢ a = b` 等价于 `a` 和 `b` 在 `R` 中存在一个共同的可达项（即 `a` 与 `b` 的 `↔*` 关系，其中 `↔` 是 `→` 的对称闭包）。

---

#### **3.2 证明论与操作语义的等价性**

在本节中，我们建立一个关键的元理论结果，它将系统M的证明论与第3节中定义的操作语义（项重写系统 `R`）精确地联系起来。我们将证明，在M的纯等式子系统（记为 M'，包含背景等式逻辑和公理A1、A2）中，一个等式是可证的，当且仅当它的两边在重写系统 `R` 中可以相互转换。

**定义 3.2.1 (关系 `↔*`)**
关系 `↔` 是 `→` 的对称闭包，即 `a ↔ b` 当且仅当 `a → b` 或 `b → a`。关系 `↔*` 是 `↔` 的自反传递闭包。因此，`a ↔* b` 意味着存在一个序列 `t_0, t_1, ..., t_n` (n ≥ 0) 使得 `a = t_0`, `b = t_n`，并且对于所有的 `i` 从 `0` 到 `n-1`，都有 `t_i ↔ t_{i+1}`。

**引理 3.2.2.a (↔\* 的合同性)**
关系 `↔*` 是一个合同关系。即，若 `a ↔* b`，则对于任意一元语境 `C[·]`，我们有 `C[a] ↔* C[b]`。

**证明：**
我们首先证明一步关系 `↔` 是一个合同关系。若 `a ↔ b`，则 `a → b` 或 `b → a`。
*   若 `a → b`，根据 `→` 的归纳定义（**定义 3.2**），对于任何语境 `C[·]`，都有 `C[a] → C[b]`。因此 `C[a] ↔ C[b]`。
*   若 `b → a`，同理，`C[b] → C[a]`，因此 `C[b] ↔ C[a]`，即 `C[a] ↔ C[b]`。
故 `↔` 是一个合同关系。

现在我们通过对 `a ↔* b` 推导的长度 `n` 进行归纳，来证明 `C[a] ↔* C[b]`。
*   **基础情况 (n=0)**: `a = b`。此时 `C[a] = C[b]`，根据 `↔*` 的自反性，`C[a] ↔* C[b]` 成立。
*   **归纳步骤**: 假设对于所有长度为 `n` 的推导 `u ↔* v`，都有 `C[u] ↔* C[v]`。考虑一个长度为 `n+1` 的推导 `a ↔* b`。它可以被分解为 `a ↔ t ↔* b`，其中 `t ↔* b` 的推导长度为 `n`。
    1.  从 `a ↔ t`，我们已经证明了 `C[a] ↔ C[t]`。
    2.  从 `t ↔* b`，根据归纳假设，我们有 `C[t] ↔* C[b]`。
    3.  结合 1 和 2，通过 `↔*` 的传递性，我们得到 `C[a] ↔* C[b]`。

归纳得证。因此，`↔*` 是一个合同关系。∎


**定理 3.2.2 (Birkhoff 完全性定理 for M')**
对于系统 M'（即系统 M 排除规则 A3 和 A4），对于任意项 `a`, `b`，我们有：
`M' ⊢ a = b` 当且仅当 `a ↔* b`。

**证明：**
本证明分为两个部分：可靠性 (⇒) 和 完备性 (⇐)。

##### **Part 1: 可靠性 (Soundness)**
**目标：** 证明若 `M' ⊢ a = b`，则 `a ↔* b`。

本证明采用对 `M' ⊢ a = b` 的推导结构进行归纳。我们必须证明 M' 的所有公理模式都满足 `↔*` 关系，并且所有推理规则都保持此关系。

**1. 基础情况 (Axioms)**
   *   **`Refl: a = a`**: 我们需要证明 `a ↔* a`。根据 `↔*` 的定义，它是自反的，因此该情况成立。
   *   **`A1: (· (equiv a b) b) = (equiv a (· a b))`**: 我们需要证明 `(· (equiv a b) b) ↔* (equiv a (· a b))`。根据重写规则 `R1`，我们有 `(· (equiv a b) b) → (equiv a (· a b))`。由 `→ ⊆ ↔*`，该情况成立。
   *   **`A2: (· a (equiv a b)) = (equiv b (· a b))`**: 我们需要证明 `(· a (equiv a b)) ↔* (equiv b (· a b))`。根据重写规则 `R2`，我们有 `(· a (equiv a b)) → (equiv b (· a b))`。由 `→ ⊆ ↔*`，该情况成立。

**2. 归纳步骤 (Inference Rules)**
   *   **`Symm: a = b / b = a`**: 归纳假设为 `a ↔* b`。我们需要证明 `b ↔* a`。根据 `↔*` 的定义，它是对称的，因此该情况成立。
   *   **`Trans: a = b, b = c / a = c`**: 归纳假设为 `a ↔* b` 且 `b ↔* c`。我们需要证明 `a ↔* c`。根据 `↔*` 的定义，它是传递的，因此该情况成立。
   *   **`Cong-·` and `Cong-equiv`**: 我们需要证明，若 `a ↔* b`，则 `(· a c) ↔* (· b c)`, `(· c a) ↔* (· c b)`, `(equiv a c) ↔* (equiv b c)` 和 `(equiv c a) ↔* (equiv c b)`。这些结论都是**引理 3.2.2.a** 的直接推论，因为 `(· [·] c)`, `(· c [·])` 等都是有效的一元语境。因此，所有合同性规则都保持 `↔*` 关系。

由于所有公理和推理规则都在 `↔*` 关系下成立，我们得出结论：若 `M' ⊢ a = b`，则 `a ↔* b`。

##### **Part 2: 完备性 (Completeness)**
**目标：** 证明若 `a ↔* b`，则 `M' ⊢ a = b`。

为了证明这一点，我们首先定义一个关系 `~`，`a ~ b` 当且仅当 `M' ⊢ a = b`。然后我们证明 `~` 是一个包含 `R` 的全等关系。

**1. 证明 `~` 是一个等价关系 (Equivalence Relation)**
   *   **自反性 (Reflexivity)**: `a ~ a` 因为 `M' ⊢ a = a` 是公理 `Refl`。
   *   **对称性 (Symmetry)**: 若 `a ~ b`，则 `M' ⊢ a = b`。根据规则 `Symm`，`M' ⊢ b = a`，因此 `b ~ a`。
   *   **传递性 (Transitivity)**: 若 `a ~ b` 且 `b ~ c`，则 `M' ⊢ a = b` 且 `M' ⊢ b = c`。根据规则 `Trans`，`M' ⊢ a = c`，因此 `a ~ c`。

**2. 证明 `~` 是一个全等关系 (Congruence Relation)**
   我们需要证明 `~` 在所有项构造器下都保持不变。
   *   若 `a ~ b`，即 `M' ⊢ a = b`。根据规则 `Cong-·`，`M' ⊢ (· a c) = (· b c)` 和 `M' ⊢ (· c a) = (· c b)`。因此 `(· a c) ~ (· b c)` 且 `(· c a) ~ (· c b)`。
   *   若 `a ~ b`，即 `M' ⊢ a = b`。根据规则 `Cong-equiv`，`M' ⊢ (equiv a c) = (equiv b c)` 和 `M' ⊢ (equiv c a) = (equiv c b)`。因此 `(equiv a c) ~ (equiv b c)` 且 `(equiv c a) ~ (equiv c b)`。
   *   综上，`~` 是一个全等关系。

**3. 证明 `R ⊆ ~`**
   我们需要证明对于 `R` 中的每一条规则 `l → r`，都有 `l ~ r`。
   *   对于规则 `R1`: `l = (· (equiv a b) b)`, `r = (equiv a (· a b))`。公理 `A1` 断言 `M' ⊢ l = r`。因此，`l ~ r`。
   *   对于规则 `R2`: `l = (· a (equiv a b))`, `r = (equiv b (· a b))`。公理 `A2` 断言 `M' ⊢ l = r`。因此，`l ~ r`。
   *   这表明由 `R` 定义的重写关系被 `~` 所包含。


**4. 结论：证明 `↔*` 的最小性**
   我们已经证明了关系 `~`（即 `M' ⊢ _ = _`）是一个包含所有重写规则 `R` 的全等关系。我们的目标是证明 `(a ↔* b) ⇒ (a ~ b)`。为此，我们必须证明 `↔*` 是包含 `R` 的**最小**全等关系。

   令 `~'` 为任意一个包含 `R` 的全等关系。我们只需证明 `↔* ⊆ ~'` 即可。
   我们将通过对 `a ↔* b` 推导的长度（即序列 `t_0, ..., t_n` 的长度 `n`）进行归纳，来证明 `(a ↔* b) ⇒ (a ~' b)`。

   *   **基础情况 (n=0)**: `a = b`。由于 `~'` 是一个全等关系，它必须是一个等价关系，因此是自反的。故 `a ~' a`，即 `a ~' b` 成立。

   *   **归纳步骤**: 假设对于所有长度为 `k ≤ n` 的推导，`u ↔* v` 蕴含 `u ~' v`。现在考虑一个长度为 `n+1` 的推导 `a ↔* b`。它可以被分解为 `a ↔* t_n ↔ b`。
      1.  根据归纳假设，`a ↔* t_n` 蕴含 `a ~' t_n`。
      2.  现在我们必须证明 `t_n ~' b`。关系 `t_n ↔ b` 意味着 `t_n → b` 或 `b → t_n`。
      3.  **情况 (i): `t_n → b`**。根据 `→` 的定义，存在一个规则 `l → r` 和一个语境 `C[·]` 使得 `t_n = C[l]` 且 `b = C[r]`。
          *   因为 `~'` 包含 `R`，所以 `l ~' r`。
          *   因为 `~'` 是一个全等关系，它在语境 `C[·]` 下是封闭的。因此，从 `l ~' r` 可推得 `C[l] ~' C[r]`。
          *   这正是 `t_n ~' b`。
      4.  **情况 (ii): `b → t_n`**。证明与情况 (i) 对称，同样可得 `b ~' t_n`。由于 `~'` 是对称的，这也意味着 `t_n ~' b`。
      5.  结合步骤 1 的 `a ~' t_n` 和步骤 3-4 的 `t_n ~' b`，利用 `~'` 的传递性，我们得到 `a ~' b`。

   归纳得证。因此，对于任何包含 `R` 的全等关系 `~'`，都有 `↔* ⊆ ~'`。这证明了 `↔*` 是包含 `R` 的最小全等关系。

   现在，回到我们的关系 `~` (即 `M' ⊢ _ = _`)。我们在步骤 1, 2, 3 中已经证明 `~` 是一个包含 `R` 的全等关系。因此，根据我们刚刚证明的最小性，必然有 `↔* ⊆ ~`。
   这等价于：若 `a ↔* b`，则 `a ~ b`，即 `M' ⊢ a = b`。

两部分证毕。∎

---

### **4. 系统性质证明 (Proof of System Properties)**

本节我们证明重写系统 `R` 具备两个关键性质：终止性和合流性。

#### **4.1. 终止性 (Termination)**

我们通过构造一个严格的良基序 (well-founded ordering) 来证明 `R` 的终止性，确保不存在无限的重写序列。

##### **定义 4.1 (度量函数 φ)**
对于任意项 `t`，我们定义其度量 `φ(t)` 为一个二元组 `(U(t), size(t))`，其构成如下：

1.  `size(t)`: 项 `t` 中符号 (常量与函数) 的总数，递归定义为：
    *   `size(T) = 1`
    *   `size(F) = 1`
    *   `size((· a b)) = 1 + size(a) + size(b)`
    *   `size((equiv a b)) = 1 + size(a) + size(b)`

2.  `U(t)`: 一个递归定义的多重集 (multiset)，其元素为自然数。我们使用 `⊎` 表示多重集的并集（元素的计数相加）。
    *   首先，定义一个辅助函数 `f(t)`：
        *   若 `t` 的形式为 `(equiv u v)`，则 `f(t) = {size(t)}` (包含 `t` 的大小的单元多重集)。
        *   否则, `f(t) = ∅` (空多重集)。
    *   `U(t)` 的递归定义如下：
        *   `U(T) = ∅`
        *   `U(F) = ∅`
        *   `U((equiv a b)) = U(a) ⊎ U(b)`
        *   `U((· a b)) = f(a) ⊎ f(b) ⊎ U(a) ⊎ U(b)`

我们使用词典序 (lexicographical order) `>` 来比较度量二元组。对于 `(U_1, s_1)` 和 `(U_2, s_2)`，`(U_1, s_1) > (U_2, s_2)` 当且仅当：
*   `U_1 >_mul U_2`，或者
*   `U_1 = U_2` 且 `s_1 > s_2`。
其中 `>_mul` 是标准的多重集序。由于自然数上的标准序 `>` 和在其上的多重集序 `>_mul` 都是良基的，因此该词典序 `>` 也是良基的。

##### **引理 4.1.a (子项度量引理)**
对于任意项 `t` 和任意自然数 `y`，若 `y ∈ U(t)`，则 `y < size(t)`。

**证明：**
本引理的证明采用对项 `t` 的结构进行归纳的方法。

*   **基础情况**:
    *   `t = T`: `U(T) = ∅`。蕴涵的前提 `y ∈ U(T)` 为假，因此命题 vacuously 成立。
    *   `t = F`: `U(F) = ∅`。同上，命题成立。

*   **归纳步骤**: 假设对于项 `a` 和 `b`，该引理成立 (此为**归纳假设**)。
    *   **情况 (i): `t = (equiv a b)`**
        `U(t) = U(a) ⊎ U(b)`。考虑任意 `y ∈ U(t)`。
        1.  若 `y ∈ U(a)`，根据归纳假设，`y < size(a)`。由于 `size(a) < 1 + size(a) + size(b) = size(t)`，我们有 `y < size(t)`。
        2.  若 `y ∈ U(b)`，根据归纳假设，`y < size(b)`。由于 `size(b) < 1 + size(a) + size(b) = size(t)`，我们有 `y < size(t)`。
        此情况成立。

    *   **情况 (ii): `t = (· a b)`**
        `U(t) = f(a) ⊎ f(b) ⊎ U(a) ⊎ U(b)`。考虑任意 `y ∈ U(t)`。
        1.  若 `y ∈ f(a)`，则 `a` 必为 `(equiv u v)` 形式且 `y = size(a)`。显然 `size(a) < 1 + size(a) + size(b) = size(t)`。
        2.  若 `y ∈ f(b)`，则 `b` 必为 `(equiv u v)` 形式且 `y = size(b)`。显然 `size(b) < 1 + size(a) + size(b) = size(t)`。
        3.  若 `y ∈ U(a)`，根据归纳假设，`y < size(a)`，因此 `y < size(t)`。
        4.  若 `y ∈ U(b)`，根据归纳假设，`y < size(b)`，因此 `y < size(t)`。
        此情况成立。

通过结构归纳，引理证毕。∎

##### **引理 4.1 (终止性)**
重写系统 `R` 是终止的 (terminating)。

**证明：**
我们必须证明对于 `R` 中的任意规则 `l → r`，均有 `φ(l) > φ(r)`，其中 `>` 是对二元组 `(U(t), size(t))` 定义的词典序。为此，我们只需证明对于每条规则，第一个分量满足 `U(l) >_mul U(r)`。`>_mul` 是标准的多重集序。

**情况 1: 规则 R1: `l = (· (equiv a b) b) → r = (equiv a (· a b))`**

1.  **计算 `U(l)`**:
    `U(l) = U((· (equiv a b) b))`
    `     = f((equiv a b)) ⊎ f(b) ⊎ U((equiv a b)) ⊎ U(b)` (根据 `U` 对 `·` 的定义)
    `     = {size((equiv a b))} ⊎ f(b) ⊎ (U(a) ⊎ U(b)) ⊎ U(b)` (根据 `f` 和 `U` 对 `equiv` 的定义)
    `     = {1 + size(a) + size(b)} ⊎ f(b) ⊎ U(a) ⊎ U(b) ⊎ U(b)`

2.  **计算 `U(r)`**:
    `U(r) = U((equiv a (· a b)))`
    `     = U(a) ⊎ U((· a b))` (根据 `U` 对 `equiv` 的定义)
    `     = U(a) ⊎ (f(a) ⊎ f(b) ⊎ U(a) ⊎ U(b))` (根据 `U` 对 `·` 的定义)
    `     = f(a) ⊎ f(b) ⊎ U(a) ⊎ U(a) ⊎ U(b)`

3.  **比较**:
    为了证明 `U(l) >_mul U(r)`，我们根据多重集序的定义，需要找到多重集 `X` 和 `Y` 使得：
    (i) `∅ ≠ X ⊆ U(l)`
    (ii) `U(r) = (U(l) \ X) ⊎ Y`
    (iii) `∀y ∈ Y, ∃x ∈ X, x > y`

    *   通过比较 `U(l)` 和 `U(r)` 的表达式，我们确定要移除和添加的元素：
        *   令 `X = {1 + size(a) + size(b)} ⊎ U(b)`。
        *   令 `Y = f(a) ⊎ U(a)`。
    *   我们逐一验证上述三个条件：
        (i) `size` 函数的值至少为1，故 `1 + size(a) + size(b) ≥ 3`，因此 `X` 是非空多重集。`X` 的所有元素显然都在 `U(l)` 中，故 `X ⊆ U(l)`。条件成立。
        (ii) 我们计算 `(U(l) \ X) ⊎ Y`：
            `  ( ({1...} ⊎ f(b) ⊎ U(a) ⊎ U(b) ⊎ U(b)) \ ({1...} ⊎ U(b)) ) ⊎ (f(a) ⊎ U(a))`
            ` = ( f(b) ⊎ U(a) ⊎ U(b) ) ⊎ (f(a) ⊎ U(a))`
            ` = f(a) ⊎ f(b) ⊎ U(a) ⊎ U(a) ⊎ U(b)`
            这与我们计算出的 `U(r)` 完全相同。条件成立。
        (iii) 令 `k = 1 + size(a) + size(b)`，它是 `X` 中的一个元素。我们证明对于 `Y` 中的任意元素 `y`，都有 `k > y`：
            *   若 `y ∈ f(a)`，则 `a` 必为 `(equiv ...)` 形式，且 `y = size(a)`。显然 `size(a) < 1 + size(a) + size(b) = k`。
			*   若 `y ∈ U(a)`，根据**引理 4.1.a**，我们有 `y < size(a)`。因此，`y < size(a) < k`。
            由于 `Y` 的所有元素都小于 `X` 中的元素 `k`，条件成立。

    由于条件 (i), (ii), (iii) 均满足，我们得出 `U(l) >_mul U(r)`。根据词典序的定义，`φ(l) > φ(r)`。

**情况 2: 规则 R2: `l = (· a (equiv a b)) → r = (equiv b (· a b))`**

1.  **计算 `U(l)`**:
    `U(l) = U((· a (equiv a b)))`
    `     = f(a) ⊎ f((equiv a b)) ⊎ U(a) ⊎ U((equiv a b))` (根据 `U` 对 `·` 的定义)
    `     = f(a) ⊎ {size((equiv a b))} ⊎ U(a) ⊎ (U(a) ⊎ U(b))` (根据 `f` 和 `U` 的定义)
    `     = {1 + size(a) + size(b)} ⊎ f(a) ⊎ U(a) ⊎ U(a) ⊎ U(b)`

2.  **计算 `U(r)`**:
    `U(r) = U((equiv b (· a b)))`
    `     = U(b) ⊎ U((· a b))` (根据 `U` 对 `equiv` 的定义)
    `     = U(b) ⊎ (f(a) ⊎ f(b) ⊎ U(a) ⊎ U(b))` (根据 `U` 对 `·` 的定义)
    `     = f(a) ⊎ f(b) ⊎ U(a) ⊎ U(b) ⊎ U(b)`

3.  **比较**:
    *   我们选择：
        *   `X = {1 + size(a) + size(b)} ⊎ U(a)`。
        *   `Y = f(b) ⊎ U(b)`。
    *   验证条件：
        (i) `X` 是非空多重集且 `X ⊆ U(l)`。条件成立。
        (ii) 我们计算 `(U(l) \ X) ⊎ Y`：
            `  ( ({1...} ⊎ f(a) ⊎ U(a) ⊎ U(a) ⊎ U(b)) \ ({1...} ⊎ U(a)) ) ⊎ (f(b) ⊎ U(b))`
            ` = ( f(a) ⊎ U(a) ⊎ U(b) ) ⊎ (f(b) ⊎ U(b))`
            ` = f(a) ⊎ f(b) ⊎ U(a) ⊎ U(b) ⊎ U(b)`
            这与我们计算出的 `U(r)` 完全相同。条件成立。
        (iii) 令 `k = 1 + size(a) + size(b)`，它是 `X` 中的一个元素。对于 `Y` 中的任意元素 `y`：
            *   若 `y ∈ f(b)`，则 `y = size(b)`。显然 `size(b) < 1 + size(a) + size(b) = k`。
            *   若 `y ∈ U(b)`，根据**引理 4.1.a**，有 `y < size(b)`。因此，`y < size(b) < k`。
            条件成立。

    因此 `U(l) >_mul U(r)`，进而 `φ(l) > φ(r)`。

由于对于 `R` 中的所有规则，左项的度量均严格大于右项的度量，且该度量所基于的词典序是良基的，因此系统 `R` 是终止的。∎

#### **4.2. 合流性 (Confluence)**

##### **引理 4.2 (局部合流性 / 菱形引理)**
重写系统 `R` 是局部合流的 (locally confluent)。

**定义 4.2.1 (局部合流性)**
一个重写系统是局部合流的，如果对于任意项 `t`, `s_1`, `s_2`，若 `t → s_1` 且 `t → s_2`，则存在一个项 `s_3`，使得 `s_1 →* s_3` 且 `s_2 →* s_3`。
这个性质可以用下图来表示：
```
    t
   / \
  ↓   ↓
s_1   s_2
  \   /
   *↓ ↓*
    s_3
```

**定义 4.2.2 (临界对)**
一个临界对产生于两条规则 `l_1 → r_1` 和 `l_2 → r_2` 的左部 `l_1` 和 `l_2` 发生重叠。具体而言，若 `l_1` 在非变量位置 `p` 处有一个子项 `l_1|p`，它可以与 `l_2` 通过最一般合一子 (most general unifier, mgu) `σ` 合一，则 `<σ(r_1), σ(l_1[r_2]_p)>` 构成一个临界对。其中 `l_1[r_2]_p` 表示将 `l_1` 在位置 `p` 的子项替换为 `r_2`。

**证明策略：**
为证明局部合流性，我们必须证明：对于任意项 `t`，若存在两次一步重写 `t → s_1` 和 `t → s_2`，则必然存在一个项 `s_3` 使得 `s_1 →* s_3` 且 `s_2 →* s_3`。

该证明的核心是系统性地分析两次重写 `t → s_1` 和 `t → s_2` 的所有可能性。为此，我们首先形式化项中子项的位置概念。

**定义 4.2.a.1 (位置)**
一个**位置** `p` 是一个布尔值列表 (`list bool`)，用于唯一标识一个项中的子项。
*   空列表 `[]` 代表项的根位置。
*   若 `p` 是项 `t` 中的一个位置，则对于形如 `(· a b)` 或 `(equiv a b)` 的项 `t`，`true :: p` 代表其左子项 `a` 中的位置 `p`，`false :: p` 代表其右子项 `b` 中的位置 `p`。

**定义 4.2.a.2 (子项与替换)**
*   `subterm(t, p)`：返回项 `t` 在位置 `p` 处的子项。
*   `replace(t, p, u)`：返回一个新项，该项通过将 `t` 在位置 `p` 的子项替换为 `u` 得到。

根据此定义，一步重写关系 `t → s` 等价于：存在一个规则 `l → r`，一个替换 `σ`，和一个位置 `p`，使得 `subterm(t, p) = Some(σ(l))` 且 `s` 是 `replace(t, p, σ(r))` 的结果。

**引理 4.2.a (可约式位置关系穷尽性)**
令 `t → s_1` 是由在位置 `p_1` 应用规则 `R_1` 产生的重写，令 `t → s_2` 是由在位置 `p_2` 应用规则 `R_2` 产生的重写。则 `p_1` 和 `p_2` 的关系必然属于以下三种情况之一：
1.  **位置相同**: `p_1 = p_2`。
2.  **位置不相交 (Disjoint)**: `p_1` 不是 `p_2` 的前缀，且 `p_2` 也不是 `p_1` 的前缀。
3.  **位置嵌套 (Nested)**: `p_1` 是 `p_2` 的一个真前缀 (proper prefix)，或者 `p_2` 是 `p_1` 的一个真前缀。

**证明：**
此引理是列表前缀关系的基本性质。对于任意两个列表，它们要么相等，要么在某一点开始不同（不相交），要么一个是另一个的真前缀。此性质覆盖了所有可能的位置关系。∎

现在，我们分析由 `s_1 ← t → s_2` 构成的分叉。令 `u_1` 和 `u_2` 分别为在位置 `p_1` 和 `p_2` 被重写的可约式。

*   **情况 1: `p_1 = p_2`**。这意味着两次重写发生在同一位置，使用了相同的可约式和规则。因此 `s_1` 和 `s_2` 在句法上是相同的。它们显然可以汇合于 `s_3 = s_1 = s_2`，重写序列长度为0。此情况是平凡的。

*   **情况 2: 位置不相交**。这意味着 `u_1` 和 `u_2` 是 `t` 中互不包含的子项。对 `u_1` 的重写 `u_1 → r_1` 发生在 `u_2` 的语境外，反之亦然。若 `t = C[u_1, u_2]`，则 `s_1 = C[r_1, u_2]` 且 `s_2 = C[u_1, r_2]`。它们显然可以通过对另一个可约式的重写而汇合于 `s_3 = C[r_1, r_2]`。此情况是平凡合流的。

*   **情况 3: 位置嵌套**。不失一般性，假设 `p_1` 是 `p_2` 的一个真前缀。这意味着可约式 `u_2` (在位置 `p_2` 被重写) 是可约式 `u_1` (在位置 `p_1` 被重写) 的一个真子项。此类重叠分为两种情况：非变量重叠和变量重叠。

    *   **子情况 3.1: 非变量重叠 (临界对分析)**
        这种情况发生在 `u_1` 的一个非变量部分的子项与另一条规则的左部 `l_2` 发生重叠。在我们的系统 `R` 中，规则的左部分别是 `l_R1 = (· (equiv a b) b)` 和 `l_R2 = (· a (equiv a b))`。
        我们必须系统性地检查一条规则的左部是否可以与另一条规则左部的非变量子项合一（unify）。

        1.  **`l_R1` 的非变量子项**: `l_R1` 在位置 `[true]` 处有一个非变量子项 `(equiv a b)`。我们检查它是否能与 `l_R1` 或 `l_R2` 合一：
            *   **合一 `(equiv a b)` 与 `l_R1 = (· (equiv a' b') b')`**: 尝试合一失败。它们的根函数符号不同，分别是 `equiv` 和 `·`。
            *   **合一 `(equiv a b)` 与 `l_R2 = (· a' (equiv a' b'))`**: 尝试合一失败。它们的根函数符号不同，分别是 `equiv` 和 `·`。

        2.  **`l_R2` 的非变量子项**: `l_R2` 在位置 `[false]` 处有一个非变量子项 `(equiv a b)`。我们检查它是否能与 `l_R1` 或 `l_R2` 合一：
            *   **合一 `(equiv a b)` 与 `l_R1 = (· (equiv a' b') b')`**: 尝试合一失败，根函数符号不同。
            *   **合一 `(equiv a b)` 与 `l_R2 = (· a' (equiv a' b'))`**: 尝试合一失败，根函数符号不同。

        由于不存在任何成功的合一，系统 `R` 不存在由非变量重叠产生的临界对。

    *   **子情况 3.2: 变量重叠**
        由于排除了非变量重叠的可能性，所有嵌套情况必然属于变量重叠。这意味着内部的可约式 `u_2` 必须是外部可约式 `u_1` 模式中某个变量 (`a` 或 `b`) 的替换实例的一部分。例如，在规则 `l_R1 = (· (equiv a b) b)` 中，`u_2` 可能是项 `a` 或项 `b` 的一个子项，或者就是 `a` 或 `b` 本身。
        我们必须对所有此类可能性进行详尽的案例分析。

接下来的案例分析将系统性地检查所有这 8 种变量重叠的可能性，从而确保所有非平凡情况的完备性。为避免变量名混淆，我们将外部规则的变量记为 `a, b`，内部规则（作为子项）的变量记为 `x, y`。

**情况 A: R1 规则的变量中包含可约式**

`l_1 = (· (equiv a b) b)`

**A.1: 变量 `a` 包含 R1 的实例**
令 `a = (· (equiv x y) y)`。构造项 `t`：
`t = (· (equiv (· (equiv x y) y) b) b)`
此项 `t` 在根部是一个 R1 实例，并且其子项 `a` 也是一个 R1 实例。

*   **路径 1 (外部优先重写)**: 对 `t` 应用 R1 规则。
    `t → (equiv (· (equiv x y) y) (· (· (equiv x y) y) b)) = s_1`

*   **路径 2 (内部优先重写)**: 先重写 `t` 的子项 `a`。
    `a = (· (equiv x y) y) → (equiv x (· x y))`
    `t → (· (equiv (equiv x (· x y)) b) b) = s_2'`
    项 `s_2'` 本身是 R1 的一个实例，对其应用 R1：
    `s_2' → (equiv (equiv x (· x y)) (· (equiv x (· x y)) b)) = s_2`

*   **汇合**: 我们证明 `s_1 →* s_2`。令 `a' = (equiv x (· x y))`。我们有 `a → a'`。
    1.  `s_1 = (equiv a (· a b))`
    2.  根据 `a → a'` 和 `→` 的合同性规则，我们可以在 `s_1` 的第一个参数中重写 `a`：
        `s_1 → (equiv a' (· a b))`
    3.  根据 `a → a'` 和 `→` 的合同性规则，我们可以在上一步结果的子项 `(· a b)` 中重写 `a`：
        `(equiv a' (· a b)) → (equiv a' (· a' b))`
    4.  最终结果 `(equiv a' (· a' b))` 与 `s_2` 完全相同。因此 `s_1 →* s_2`。两个分支汇合。

**A.2: 变量 `b` 包含 R1 的实例**
令 `b = (· (equiv x y) y)`。构造项 `t`：
`t = (· (equiv a (· (equiv x y) y)) (· (equiv x y) y))`

*   **路径 1**: `t → (equiv a (· a (· (equiv x y) y))) = s_1`
*   **路径 2**: `t → (· (equiv a (equiv x (· x y))) (equiv x (· x y))) = s_2'`
    `s_2'` 是 R1 的实例，重写得到:
    `s_2' → (equiv a (· a (equiv x (· x y)))) = s_2`
*   **汇合**: 我们证明 `s_1 →* s_2`。令 `b' = (equiv x (· x y))`。我们有 `b → b'`。
    1.  `s_1 = (equiv a (· a b))`
    2.  根据 `b → b'` 和 `→` 的合同性规则，我们可以在 `s_1` 的子项 `(· a b)` 中重写 `b`：
        `s_1 → (equiv a (· a b'))`
    3.  最终结果 `(equiv a (· a b'))` 与 `s_2` 完全相同。因此 `s_1 →* s_2`。两个分支汇合。

**A.3: 变量 `a` 包含 R2 的实例**
令 `a = (· x (equiv x y))`。构造项 `t`：
`t = (· (equiv (· x (equiv x y)) b) b)`

*   **路径 1**: `t → (equiv (· x (equiv x y)) (· (· x (equiv x y)) b)) = s_1`
*   **路径 2**: `t → (· (equiv (equiv y (· x y)) b) b) = s_2'`
    `s_2' → (equiv (equiv y (· x y)) (· (equiv y (· x y)) b)) = s_2`
*   **汇合**: 我们证明 `s_1 →* s_2`。令 `a' = (equiv y (· x y))`。我们有 `a → a'`。
    1.  `s_1 = (equiv a (· a b))`
    2.  `s_1 → (equiv a' (· a b))` (在第一个参数中重写 `a`)
    3.  `(equiv a' (· a b)) → (equiv a' (· a' b))` (在第二个参数的子项中重写 `a`)
    4.  最终结果与 `s_2` 完全相同。因此 `s_1 →* s_2`。两个分支汇合。

**A.4: 变量 `b` 包含 R2 的实例**
令 `b = (· x (equiv x y))`。构造项 `t`：
`t = (· (equiv a (· x (equiv x y))) (· x (equiv x y)))`

*   **路径 1**: `t → (equiv a (· a (· x (equiv x y)))) = s_1`
*   **路径 2**: `t → (· (equiv a (equiv y (· x y))) (equiv y (· x y))) = s_2'`
    `s_2' → (equiv a (· a (equiv y (· x y)))) = s_2`
*   **汇合**: 我们证明 `s_1 →* s_2`。令 `b' = (equiv y (· x y))`。我们有 `b → b'`。
    1.  `s_1 = (equiv a (· a b))`
    2.  `s_1 → (equiv a (· a b'))` (在子项 `(· a b)` 中重写 `b`)
    3.  最终结果与 `s_2` 完全相同。因此 `s_1 →* s_2`。两个分支汇合。

---
**情况 B: R2 规则的变量中包含可约式**

`l_2 = (· a (equiv a b))`

**B.1: 变量 `a` 包含 R1 的实例**
令 `a = (· (equiv x y) y)`。构造项 `t`：
`t = (· (· (equiv x y) y) (equiv (· (equiv x y) y) b))`

*   **路径 1**: `t → (equiv b (· (· (equiv x y) y) b)) = s_1`
*   **路径 2**: `t → (· (equiv x (· x y)) (equiv (equiv x (· x y)) b)) = s_2'`
    `s_2'` 是 R2 的实例，重写得到:
    `s_2' → (equiv b (· (equiv x (· x y)) b)) = s_2`
*   **汇合**: 我们证明 `s_1 →* s_2`。令 `a' = (equiv x (· x y))`。我们有 `a → a'`。
    1.  `s_1 = (equiv b (· a b))`
    2.  `s_1 → (equiv b (· a' b))` (在子项 `(· a b)` 中重写 `a`)
    3.  最终结果与 `s_2` 完全相同。因此 `s_1 →* s_2`。两个分支汇合。

**B.2: 变量 `b` 包含 R1 的实例**
令 `b = (· (equiv x y) y)`。构造项 `t`：
`t = (· a (equiv a (· (equiv x y) y)))`

*   **路径 1**: `t → (equiv (· (equiv x y) y) (· a (· (equiv x y) y))) = s_1`
*   **路径 2**: `t → (· a (equiv a (equiv x (· x y)))) = s_2'`
    `s_2' → (equiv (equiv x (· x y)) (· a (equiv x (· x y)))) = s_2`
*   **汇合**: 我们证明 `s_1 →* s_2`。令 `b' = (equiv x (· x y))`。我们有 `b → b'`。
    1.  `s_1 = (equiv b (· a b))`
    2.  `s_1 → (equiv b' (· a b))` (在第一个参数中重写 `b`)
    3.  `(equiv b' (· a b)) → (equiv b' (· a b'))` (在第二个参数的子项中重写 `b`)
    4.  最终结果与 `s_2` 完全相同。因此 `s_1 →* s_2`。两个分支汇合。

**B.3: 变量 `a` 包含 R2 的实例**
令 `a = (· x (equiv x y))`。构造项 `t`：
`t = (· (· x (equiv x y)) (equiv (· x (equiv x y)) b))`

*   **路径 1**: `t → (equiv b (· (· x (equiv x y)) b)) = s_1`
*   **路径 2**: `t → (· (equiv y (· x y)) (equiv (equiv y (· x y)) b)) = s_2'`
    `s_2' → (equiv b (· (equiv y (· x y)) b)) = s_2`
*   **汇合**: 我们证明 `s_1 →* s_2`。令 `a' = (equiv y (· x y))`。我们有 `a → a'`。
    1.  `s_1 = (equiv b (· a b))`
    2.  `s_1 → (equiv b (· a' b))` (在子项 `(· a b)` 中重写 `a`)
    3.  最终结果与 `s_2` 完全相同。因此 `s_1 →* s_2`。两个分支汇合。

**B.4: 变量 `b` 包含 R2 的实例**
令 `b = (· x (equiv x y))`。构造项 `t`：
`t = (· a (equiv a (· x (equiv x y))))`

*   **路径 1**: `t → (equiv (· x (equiv x y)) (· a (· x (equiv x y)))) = s_1`
*   **路径 2**: `t → (· a (equiv a (equiv y (· x y)))) = s_2'`
    `s_2' → (equiv (equiv y (· x y)) (· a (equiv y (· x y)))) = s_2`
*   **汇合**: 我们证明 `s_1 →* s_2`。令 `b' = (equiv y (· x y))`。我们有 `b → b'`。
    1.  `s_1 = (equiv b (· a b))`
    2.  `s_1 → (equiv b' (· a b))` (在第一个参数中重写 `b`)
    3.  `(equiv b' (· a b)) → (equiv b' (· a b'))` (在第二个参数的子项中重写 `b`)
    4.  最终结果与 `s_2` 完全相同。因此 `s_1 →* s_2`。两个分支汇合。


**结论:**
我们已经系统性地检查了所有可能的重叠（在此系统中仅由可约式重叠产生）。在每种情况下，由不同重写选择产生的两个分支 `s_1` 和 `s_2` 都被证明是可汇合的。因此，重写系统 `R` 是局部合流的。∎

##### **定理 4.3 (合流性)**
重写系统 `R` 是合流的 (confluent)。

**证明：**
根据**纽曼引理 (Newman's Lemma)**，一个终止的项重写系统是合流的，当且仅当它是局部合流的。
1.  由引理 4.1，我们证明了 `R` 是终止的。
2.  由引理 4.2，我们证明了 `R` 是局部合流的。
因此，系统 `R` 是合流的。∎

##### **推论 4.4 (唯一正规形式)**
对于任意项 `t`，存在一个唯一的正规形式 `s` 使得 `t →* s`。我们将这个唯一的正规形式记为 `NF(t)`。

### **5. 句法性质与一致性 (Syntactic Properties and Consistency)**

本节将分析系统 M 的两个关键元理论性质：一个关于应用函数 `·` 数量的句法不变量，以及系统的非平凡一致性。我们指出，这里的两个一致性证明都依赖于经典逻辑，使用了排中律。我们不计划寻求一个构造性的证明。

#### **5.1. 应用数守恒性质 (Conservation Property of Application Count)**

我们首先定义一个度量函数，用于计算项中应用函数 `·` 的出现次数，并证明一个与此度量相关的关键引理。

##### **定义 5.1.1 (应用函数计数)**
函数 `C_·(t)`，表示项 `t` 中函数符号 `·` 的出现总次数，其递归定义如下：
1.  `C_·(T) = 0`
2.  `C_·(F) = 0`
3.  `C_·((equiv a b)) = C_·(a) + C_·(b)`
4.  `C_·((· a b)) = 1 + C_·(a) + C_·(b)`

##### **引理 5.1.2 (应用数1-集在 ↔\* 下的封闭性)**
令 `S_1` 为所有满足 `C_·(t) = 1` 的项 `t` 的集合。若 `t ∈ S_1` 且 `t ↔* s`，则 `s ∈ S_1`。

**证明：**
为了证明 `S_1` 在自反传递闭包 `↔*` 下是封闭的，我们仅需证明它在单步对称关系 `↔` 下是封闭的。即，若 `t ∈ S_1` 且 `t ↔ s`，则 `s ∈ S_1`。这需要考虑 `t → s` 和 `s → t` 两种情况。

**情况 1: `t → s`，其中 `t ∈ S_1`**
1.  根据定义 5.1.1，若 `C_·(t) = 1`，则项 `t` 的顶层结构必须是 `(· X Y)`，且其直接子项 `X` 和 `Y` 必须不含 `·` 函数，即 `C_·(X) = 0` 且 `C_·(Y) = 0`。
2.  因为 `t → s`，项 `t` 必须包含一个可约式。由于重写规则 R1 和 R2 的左部都以 `·` 为根，而 `X` 和 `Y` 是 `·`-自由的，所以 `X` 和 `Y` 不可能包含可约式。因此，唯一可能的可约式就是 `t` 本身。
3.  项 `t = (· X Y)` 必须匹配规则 R1 或 R2 的左部模式。
    *   **子情况 (a):** `t` 匹配 `(· (equiv a b) b)` (R1)。
        此时 `X = (equiv a b)` 且 `Y = b`。由 `C_·(X) = 0` 和 `C_·(Y) = 0`，可推得 `C_·(a) = 0` 且 `C_·(b) = 0`。
        重写后的项为 `s = (equiv a (· a b))`。
        我们计算 `s` 的应用数：
        `C_·(s) = C_·((equiv a (· a b))) = C_·(a) + C_·((· a b)) = C_·(a) + (1 + C_·(a) + C_·(b))`
        代入 `C_·(a) = 0` 和 `C_·(b) = 0`，得 `C_·(s) = 0 + (1 + 0 + 0) = 1`。
        故 `s ∈ S_1`。
    *   **子情况 (b):** `t` 匹配 `(· a (equiv a b))` (R2)。
        此时 `X = a` 且 `Y = (equiv a b)`。由 `C_·(X) = 0` 和 `C_·(Y) = 0`，可推得 `C_·(a) = 0` 且 `C_·(b) = 0`。
        重写后的项为 `s = (equiv b (· a b))`。
        我们计算 `s` 的应用数：
        `C_·(s) = C_·((equiv b (· a b))) = C_·(b) + C_·((· a b)) = C_·(b) + (1 + C_·(a) + C_·(b))`
        代入 `C_·(a) = 0` 和 `C_·(b) = 0`，得 `C_·(s) = 0 + (1 + 0 + 0) = 1`。
        故 `s ∈ S_1`。
此两种子情况表明，若 `t ∈ S_1` 且 `t → s`，则 `s ∈ S_1`。

**情况 2: `s → t`，其中 `t ∈ S_1`**
1.  若 `s → t`，则 `t` 必须是规则 R1 或 R2 右部的一个实例。
2.  若 `t` 是 `(equiv a (· a b))` 的实例，则 `C_·(t) = C_·(a) + C_·((· a b)) = 1 + 2·C_·(a) + C_·(b)`。
3.  若 `t` 是 `(equiv b (· a b))` 的实例，则 `C_·(t) = C_·(b) + C_·((· a b)) = 1 + C_·(a) + 2·C_·(b)`。
4.  我们已知 `t ∈ S_1`，即 `C_·(t) = 1`。在上述两种表达式中，由于 `C_·` 函数的值是非负整数，这都必然要求 `C_·(a) = 0` 且 `C_·(b) = 0`。
5.  项 `s` 必定是对应规则左部的实例。
    *   若 `t` 是 R1 右部的实例，则 `s = (· (equiv a b) b)`。我们计算 `s` 的应用数：
        `C_·(s) = 1 + C_·((equiv a b)) + C_·(b) = 1 + (C_·(a) + C_·(b)) + C_·(b) = 1 + 0 + 0 + 0 = 1`。
        故 `s ∈ S_1`。
    *   若 `t` 是 R2 右部的实例，则 `s = (· a (equiv a b))`。我们计算 `s` 的应用数：
        `C_·(s) = 1 + C_·(a) + C_·((equiv a b)) = 1 + C_·(a) + (C_·(a) + C_·(b)) = 1 + 0 + 0 + 0 = 1`。
        故 `s ∈ S_1`。
此情况表明，若 `t ∈ S_1` 且 `s → t`，则 `s ∈ S_1`。

**结论：**
由于 `S_1` 在 `→` 及其逆关系 `←` 下都是封闭的，因此它在 `↔` 下是封闭的。根据归纳法，`S_1` 在 `↔` 的自反传递闭包 `↔*` 下也是封闭的。∎

#### **5.2. 构造性的非平凡一致性证明 (Non-trivial Consistency)**
暂缺。

#### **5.3. 通过句法不变量证明一致性 (Consistency via Syntactic Invariant)**

本节利用第 5.1 节建立的应用数守恒性质来提供系统 M 非平凡一致性的一个直接证明。我们将证明一个特定的、结构上不匹配的等式是不可证的。

##### **5.3.1. 将 M-可证性归约至 M'-可证性 (Reduction of M-provability to M'-provability)**

**命题 5.3.1.** 若 `M ⊢ T = (· T T)`，则必有 `M' ⊢ T = (· T T)`。

**证明：**
为证明此命题，我们首先建立一个关于系统 M 和 M' 之间关系的一般性引理。

**引理 5.3.1.1.** 令 `u = v` 为任意公式。若 `M ⊢ u = v` 但 `M' ⊬ u = v`，则 `u = v` 的证明必然可以转化为以下两种结构之一：
   (a) 存在项 `a, b` 使得 `u = (equiv a b)` 且 `v = T`，并且 `M' ⊢ a = b`。
   (b) 存在项 `a, b` 使得 `u = a` 且 `v = b`，并且 `M' ⊢ (equiv a b) = T`。

**引理证明：**
我们采用反证法。假设存在一个公式集合 `S = { φ | M ⊢ φ 且 M' ⊬ φ }`，该集合非空。由于任何证明的长度都是一个正整数，根据自然数的良序原理，必然存在一个 `φ ∈ S`，其在 `M` 中的证明 `D` 具有**最小长度**。令 `φ` 为 `u = v`。我们分析推导出 `u = v` 的 `D` 的最后一步推理规则：

*   **情况 (i): 最后一步是 M' 的推理规则之一** (即 `Symm`, `Trans`, `Cong-*`)。
    以 `Trans` 为例：`u = v` 是由前提 `u = w` 和 `w = v` 推导得出。这两个前提的证明长度严格小于 `D` 的长度。根据 `D` 长度的最小性，这两个前提公式不能属于集合 `S`。因此，必有 `M' ⊢ u = w` 且 `M' ⊢ w = v`。然而，由于 `M'` 对其自身的推理规则（包括 `Trans`）是封闭的，故可立即推得 `M' ⊢ u = v`。但这与 `u = v ∈ S` 的假设相矛盾。对于其他 `M'` 规则的分析将导出同样的矛盾。因此，`D` 的最后一步不可能是 `M'` 的规则。

*   **情况 (ii): 最后一步是 M 的规则 (A3 或 A4)**。
    由于情况 (i) 已被排除，`D` 的最后一步必然是 A3 或 A4。
    *   **子情况 (ii-a): 最后一步是 A4: 内化规则**，`a = b / (equiv a b) = T`。
        此时，`u = (equiv a b)` 且 `v = T`。其前提 `a = b` 的证明长度严格小于 `D`。根据 `D` 长度的最小性，`a = b` 不属于 `S`，因此 `M' ⊢ a = b`。这完全符合引理结论 (a) 的结构。
    *   **子情况 (ii-b): 最后一步是 A3: 外化规则**，`(equiv a b) = T / a = b`。
        此时，`u = a` 且 `v = b`。其前提 `(equiv a b) = T` 的证明长度严格小于 `D`。根据 `D` 长度的最小性，`(equiv a b) = T` 不属于 `S`，因此 `M' ⊢ (equiv a b) = T`。这完全符合引理结论 (b) 的结构。

综上所述，任何在 `M` 中可证但在 `M'` 中不可证的公式，其最小长度证明的结构必然符合引理所述。引理证毕。∎

###### **命题 5.3.1** (M的证明归约到M')
若 `M ⊢ T = (· T T)`，则必有 `M' ⊢ T = (· T T)`。

**证明：**
本证明采用反证法。我们首先假设命题的结论为假，并从该假设导出一个矛盾。

1.  **初始假设**:
    a. `M ⊢ T = (· T T)` (命题的前提)
    b. `M' ⊬ T = (· T T)` (我们为导出矛盾而做的假设)

2.  **应用引理 5.3.1.1**:
    根据上述两个假设，公式 `φ ≡ (T = (· T T))` 是一个在系统 `M` 中可证，但在系统 `M'` 中不可证的公式。因此，`φ` 满足**引理 5.3.1.1** 的条件。该引理断言，`φ` 在 `M` 中的任意最短证明，其最后一步推理必然是规则 A3 或 A4。我们对这两种可能性进行分析。

3.  **情况分析：证明的最后一步**

    *   **情况 (a): 最后一步是规则 A4 (内化规则)**
        该规则的形式为 `a = b / (equiv a b) = T`。
        若 `φ` 是由此规则导出，则 `φ` 的结构必须与规则的结论 `(equiv a b) = T` 相匹配。
        这意味着：
        i.  `T` 必须匹配 `(equiv a b)`。
        ii. `(· T T)` 必须匹配 `T`。
        条件 (ii) `(· T T) = T` 是一个句法上的不匹配。原子项 `T` 在句法上不可能等同于复合项 `(· T T)`。因此，`φ` 的证明的最后一步不可能是规则 A4。

    *   **情况 (b): 最后一步是规则 A3 (外化规则)**
        该规则的形式为 `(equiv a b) = T / a = b`。
        若 `φ` 是由此规则导出，则 `φ` 的结构必须与规则的结论 `a = b` 相匹配。
        这意味着：
        i.  `a` 必须匹配 `T`。
        ii. `b` 必须匹配 `(· T T)`。
        根据引理 5.3.1.1 的证明逻辑，此规则的前提 `(equiv a b) = T` 必须在 `M'` 中是可证的（否则就存在一个更短的、在 `M` 中可证但在 `M'` 中不可证的证明，与我们选择 `φ` 为最短证明的前提相矛盾）。
        将 `a` 和 `b` 替换为匹配的项，我们得出结论：
        `M' ⊢ (equiv T (· T T)) = T`。

4.  **导出矛盾**:
    我们现在从步骤 3(b) 的结论 `M' ⊢ (equiv T (· T T)) = T` 出发，推导出一个矛盾。
    a.  根据**定理 3.2.2 (Birkhoff 完全性定理 for M')**，`M'` 中的可证性 `⊢` 等价于重写系统中的 `↔*` 关系。因此，`M' ⊢ (equiv T (· T T)) = T` 蕴含 `(equiv T (· T T)) ↔* T`。
    b.  令 `u = (equiv T (· T T))` 且 `v = T`。我们有 `u ↔* v`。
    c.  我们计算 `u` 的应用函数数。根据**定义 5.1.1**：
        `C_·(u) = C_·((equiv T (· T T))) = C_·(T) + C_·((· T T)) = 0 + (1 + C_·(T) + C_·(T)) = 1`。
    d.  因此，`u` 属于集合 `S_1 = {t | C_·(t) = 1}`。
    e.  根据**引理 5.1.2 (应用数1-集在 ↔\* 下的封闭性)**，若 `u ∈ S_1` 且 `u ↔* v`，则必有 `v ∈ S_1`。
    f.  `v ∈ S_1` 意味着 `C_·(v) = 1`。
    g.  然而，我们计算 `v` 的应用函数数： `C_·(v) = C_·(T) = 0`。
    h.  步骤 4(f) 和 4(g) 导出了矛盾：`1 = 0`。

5.  **结论**:
    我们在第 1(b) 步的假设 `M' ⊬ T = (· T T)` 最终导出了一个算术矛盾。因此，该假设为假。
    这意味着，若 `M ⊢ T = (· T T)` 成立，则 `M' ⊢ T = (· T T)` 必然成立。

命题 5.3.1 证毕。∎

##### **定理 5.3.2 (非平凡一致性)**
系统 M 是非平凡一致的，具体而言，公式 `T = (· T T)` 在系统 M 中是不可证的。即 `M ⊬ T = (· T T)`。

**证明：**
为证明 `M ⊬ T = (· T T)`，我们展示任何 `M ⊢ T = (· T T)` 的假设都会导出一个矛盾。这在构造性逻辑中等价于证明蕴涵式 `(M ⊢ T = (· T T)) → False`。证明流程如下：

1.  **假设**我们有一个 `M ⊢ T = (· T T)` 的证明。

2.  根据**命题 5.3.1**，此假设蕴含 `M' ⊢ T = (· T T)`。

3.  根据**定理 3.2.2**，`M' ⊢ T = (· T T)` 等价于 `T ↔* (· T T)`。

4.  现在我们利用**引理 5.1.2** 导出矛盾：
    1.  令项 `u = (· T T)`。根据**定义 5.1.1**，其应用函数数为 `C_·(u) = 1 + C_·(T) + C_·(T) = 1`。因此 `u ∈ S_1`。
    2.  令项 `v = T`。根据**定义 5.1.1**，其应用函数数为 `C_·(v) = 0`。
    3.  从步骤 3，我们有 `u ↔* v`。
    4.  根据**引理 5.1.2**，若 `u ∈ S_1` 且 `u ↔* v`，则必有 `v ∈ S_1`。
    5.  `v ∈ S_1` 意味着 `C_·(v) = 1`。
    6.  这与步骤 4.2 中计算出的 `C_·(v) = 0` 相矛盾。

5.  **结论**：
    我们的初始假设 `M ⊢ T = (· T T)` 导出了一个算术矛盾 `1 = 0`。因此，该假设为假。
    故 `M ⊬ T = (· T T)`。由于存在一个在系统 M 中不可证的公式，系统 M 被证明是非平凡一致的。

∎
