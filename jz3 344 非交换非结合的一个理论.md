## **形式化理论 Tₑ 及其标准模型 M**

### **1. 语法与证明论 (Syntax and Proof Theory)**

#### **1.1. 语言 L**

形式化理论 **Tₑ** 建立在一阶语言 L 之上，其构成为：
*   **变量 (Variables):** 一个可数无限集 `V = {x, y, z, a, b, ...}`。
*   **常量符号 (Constant Symbols):** `C = {1}`。
*   **函数符号 (Function Symbols):** `F = { ·/2, equiv/2 }` (二元函数)。
*   **谓词符号 (Predicate Symbols):** `P = { =/2 }` (二元谓词)。
*   **逻辑符号 (Logical Symbols):** `¬`, `→`, `∀`。
*   **辅助符号 (Auxiliary Symbols):** `(`, `)`。

**项 (Terms):** L-项的集合 `Term(L)` 归纳定义如下：
1.  所有变量 `v ∈ V` 都是项。
2.  常量 `1` 是一个项。
3.  若 `t₁` 和 `t₂` 是项，则 `·(t₁, t₂)` 是一个项。
4.  若 `t₁` 和 `t₂` 是项，则 `equiv(t₁, t₂)` 是一个项。

**公式 (Formulas):** L-公式的集合 `Form(L)` 归纳定义如下：
1.  若 `t₁` 和 `t₂` 是项，则 `t₁ = t₂` 是一个原子公式。
2.  若 `φ` 是公式，则 `¬φ` 是公式。
3.  若 `φ` 和 `ψ` 是公式，则 `(φ → ψ)` 是公式。
4.  若 `φ` 是公式且 `v ∈ V`，则 `∀v φ` 是公式。
(其他联结词 `∧, ∨, ↔` 和量词 `∃` 可作为标准宏定义。)

#### **1.2. 证明系统 (Deductive System)**

**Tₑ** 的证明系统是一阶逻辑的希尔伯特式系统，包含以下公理模式和推理规则：

**逻辑公理:**
*   **(命题逻辑公理):** 任何命题逻辑重言式实例。
*   **(量词公理):** `∀v φ(v) → φ(t)`，其中项 `t` 在 `φ` 中对 `v` 可代入。
*   **(等价关系公理):**
    *   `∀x (x = x)` (Reflexivity)
    *   `∀x ∀y (x = y → y = x)` (Symmetry)
    *   `∀x ∀y ∀z ((x = y ∧ y = z) → x = z)` (Transitivity)
*   **(同余公理):**
    *   `∀x₁ ∀y₁ ∀x₂ ∀y₂ ((x₁ = x₂ ∧ y₁ = y₂) → ·(x₁, y₁) = ·(x₂, y₂))`
    *   `∀x₁ ∀y₁ ∀x₂ ∀y₂ ((x₁ = x₂ ∧ y₁ = y₂) → equiv(x₁, y₁) = equiv(x₂, y₂))`

**非逻辑公理 (Axioms of Tₑ):**
*   **(A1):** `∀a (equiv(a, a) = 1)`
*   **(A2):** `∀a ∀b (equiv(a, b) = equiv(b, a))`
*   **(A3):** `∀a ∀b ∀x (equiv(·(a, b), x) = ·(x, equiv(a, b)))`
*   **(A4):** `∀a ∀b ∀x (equiv(x, ·(a, b)) = ·(equiv(a, b), x))`

**推理规则 (Rules of Inference):**
*   **(肯定前件 Modus Ponens):** 从 `φ` 和 `φ → ψ`，可推出 `ψ`。
*   **(泛化规则 Generalization):** 从 `φ`，可推出 `∀v φ`。

一个公式 `φ` 可从 **Tₑ** 证明，记为 `Tₑ ⊢ φ`，当且仅当存在一个有限的公式序列（即一个证明），其最后一个公式为 `φ`，且序列中每个公式均为 **Tₑ** 的公理或由前面的公式通过推理规则得到。

---

### **2. 模型论语义 (Model-Theoretic Semantics)**

#### **2.1. L-结构 (L-Structure)**
一个 L-结构是一个四元组 `A = (U, ·ᴬ, equivᴬ, 1ᴬ)`，其中 `U` 是非空论域，`·ᴬ: U × U → U` 和 `equivᴬ: U × U → U` 是二元运算，`1ᴬ` 是 `U` 中的一个元素。

#### **2.2. 模型 M 的构造**

1.  **生成元集合 (Set of Generators):**
    令 `G = {g₀, g₁, g₂, ...}` 为一个可数无限的、新的常量符号集合。令 `L⁺ = L ∪ G`。

2.  **无变量项集合 (Set of Ground Terms):**
    令 `T` 为在 `L⁺` 上的所有无变量项（ground terms）的集合。

3.  **可证等价关系 (Provable Equivalence Relation):**
    在 `T` 上定义一个二元关系 `~` 如下：对于任意 `t₁, t₂ ∈ T`，
    `t₁ ~ t₂`  当且仅当  `Tₑ ⊢ t₁ = t₂`。
    (这里的证明 `⊢` 是在扩展语言 `L⁺` 上进行的，其中 `G` 中的元素被视为常量。)

    **引理 2.2.1:** `~` 是 `T` 上的一个同余关系。
    **证明:**
    *   **自反性:** 对于任意 `t ∈ T`，`Tₑ ⊢ t = t`，因为 `∀x(x=x)` 是逻辑公理。故 `t ~ t`。
    *   **对称性:** 若 `t₁ ~ t₂`，则 `Tₑ ⊢ t₁ = t₂`。由对称性公理 `∀x∀y(x=y → y=x)` 和肯定前件，可得 `Tₑ ⊢ t₂ = t₁`。故 `t₂ ~ t₁`。
    *   **传递性:** 若 `t₁ ~ t₂` 且 `t₂ ~ t₃`，则 `Tₑ ⊢ t₁ = t₂` 且 `Tₑ ⊢ t₂ = t₃`。由合取引入和传递性公理 `∀x∀y∀z((x=y ∧ y=z) → x=z)` 及肯定前件，可得 `Tₑ ⊢ t₁ = t₃`。故 `t₁ ~ t₃`。
    *   **同余性:** 假设 `t₁ ~ t₁'` 且 `t₂ ~ t₂'`。这意味着 `Tₑ ⊢ t₁ = t₁'` 且 `Tₑ ⊢ t₂ = t₂'`。由同余公理 `∀x₁...∀y₂((x₁=x₂ ∧ y₁=y₂) → ·(x₁,y₁)=·(x₂,y₂))` 和肯定前件，可得 `Tₑ ⊢ ·(t₁,t₂) = ·(t₁',t₂')`。故 `·(t₁, t₂) ~ ·(t₁', t₂')`。`equiv` 函数的同余性同理可证。
    引理证毕。

4.  **商模型 M (Quotient Model M):**
    *   **论域 (Domain):** `Uₘ = T/~ = {[t] | t ∈ T}`，其中 `[t]` 是 `t` 在 `~` 关系下的等价类。
    *   **常量解释:** `1ᴹ = [1]`
    *   **函数解释:** 对于任意 `[t₁], [t₂] ∈ Uₘ`：
        *   `·ᴹ([t₁], [t₂]) = [·(t₁, t₂)]`
        *   `equivᴹ([t₁], [t₂]) = [equiv(t₁, t₂)]`

    根据引理 2.2.1，`~` 是同余关系，因此 `·ᴹ` 和 `equivᴹ` 的定义是良定义的 (well-defined)。结构 `M = (Uₘ, ·ᴹ, equivᴹ, 1ᴹ)` 是一个 L-结构，通常称为 **Tₑ** 的项模型或典范模型。

---

### **3. 可靠性与完备性 (Soundness and Completeness)**

#### **3.1. Tₑ 对 M 的可靠性与完备性 (针对无变量等式)**

**引理 3.1.1:** 对于 `L⁺` 上的任意无变量项 `t`，其在模型 `M` 中的解释 `tᴹ` 等于 `t` 所属的等价类 `[t]`。
**证明:** 对项 `t` 的结构进行归纳。
1.  **基本情况:**
    *   若 `t` 是常量符号 `1`，根据 `M` 的定义，`1ᴹ = [1]`。引理成立。
    *   若 `t` 是 `G` 中的一个生成元 `gᵢ` (在 `L⁺` 中视为常量)，根据 `M` 的定义，`gᵢᴹ = [gᵢ]`。引理成立。

2.  **归纳步骤:**
    *   假设对于无变量项 `t₁` 和 `t₂`，有 `t₁ᴹ = [t₁]` 且 `t₂ᴹ = [t₂]`。
    *   考虑项 `t = ·(t₁, t₂)`。根据 `M` 中函数解释的定义：
        `tᴹ = (·(t₁, t₂))ᴹ = ·ᴹ(t₁ᴹ, t₂ᴹ)`
        根据归纳假设，`t₁ᴹ = [t₁]` 且 `t₂ᴹ = [t₂]`，代入得：
        `·ᴹ([t₁], [t₂])`
        根据 `·ᴹ` 的定义，这等于：
        `[·(t₁, t₂)] = [t]`
        故对于 `t = ·(t₁, t₂)`，引理成立。
    *   同理，考虑项 `t = equiv(t₁, t₂)`。
        `tᴹ = (equiv(t₁, t₂))ᴹ = equivᴹ(t₁ᴹ, t₂ᴹ) = equivᴹ([t₁], [t₂]) = [equiv(t₁, t₂)] = [t]`
        故对于 `t = equiv(t₁, t₂)`，引理成立。

根据结构归纳法，引理对所有 `L⁺` 上的无变量项成立。**引理证毕。**

**定理 3.1.2:** 对于任意 `L⁺` 上的无变量项 `t₁, t₂`，`Tₑ ⊢ t₁ = t₂` 当且仅当 `M ⊨ t₁ = t₂`。
**证明:**
*   **(`⇒`) 可靠性方向:**
    1.  假设 `Tₑ ⊢ t₁ = t₂`。
    2.  根据关系 `~` 的定义，这意味着 `t₁ ~ t₂`。
    3.  根据 `Uₘ` 的商集构造，这意味着等价类 `[t₁]` 和 `[t₂]` 是 `Uₘ` 中的同一个元素，即 `[t₁] = [t₂]`。
    4.  根据引理 3.1.1，我们有 `t₁ᴹ = [t₁]` 且 `t₂ᴹ = [t₂]`。
    5.  因此，`t₁ᴹ = t₂ᴹ`。
    6.  根据模型 `M` 中 ` = ` 的标准解释，`t₁ᴹ = t₂ᴹ` 即为 `M ⊨ t₁ = t₂`。

*   **(`⇐`) 完备性方向:**
    1.  假设 `M ⊨ t₁ = t₂`。
    2.  根据模型 `M` 中 ` = ` 的标准解释，这意味着 `t₁ᴹ = t₂ᴹ`。
    3.  根据引理 3.1.1，我们有 `t₁ᴹ = [t₁]` 且 `t₂ᴹ = [t₂]`。
    4.  因此，`[t₁] = [t₂]`。
    5.  根据 `Uₘ` 的商集构造，这意味着 `t₁ ~ t₂`。
    6.  根据关系 `~` 的定义，这意味着 `Tₑ ⊢ t₁ = t₂`。
**定理证毕。**

#### **3.2. 一致性定理 (Consistency Theorem)**

**定理 3.2.1:** 结构 `M` 是理论 **Tₑ** 的一个模型，即 `M ⊨ Tₑ`。
**证明:** 我们必须证明 **Tₑ** 的所有公理（包括逻辑公理和非逻辑公理）在 `M` 中为真。一个全称量化的公式 `∀v₁...∀vₙ φ` 在 `M` 中为真，当且仅当对于论域 `Uₘ` 中元素的任意赋值 `d₁,...,dₙ` 到变量 `v₁,...,vₙ`，公式 `φ` 都被满足。由于 `Uₘ = T/~`，任意 `dᵢ` 都可以表示为某个无变量项 `tᵢ` 的等价类 `[tᵢ]`。因此，验证公理的真值等价于验证对于任意无变量项 `t₁, ..., tₙ`，公理的主体部分在 `[t₁], ..., [tₙ]` 的赋值下成立。

1.  **等价关系公理的验证 (以传递性为例):**
    `∀x ∀y ∀z ((x = y ∧ y = z) → x = z)`
    我们需要对任意 `[t₁], [t₂], [t₃] ∈ Uₘ`，验证 `M ⊨ ([t₁]=[t₂] ∧ [t₂]=[t₃]) → [t₁]=[t₃]`。
    假设 `M ⊨ [t₁]=[t₂]` 且 `M ⊨ [t₂]=[t₃]`。
    这意味着 `[t₁]=[t₂]` 且 `[t₂]=[t₃]`。
    根据等价类的性质，这直接蕴含 `[t₁]=[t₃]`，即 `M ⊨ [t₁]=[t₃]`。
    因此，该公理在 `M` 中为真。自反性和对称性同理可证。

2.  **同余公理的验证 (以 `·` 为例):**
    `∀x₁ ∀y₁ ∀x₂ ∀y₂ ((x₁ = x₂ ∧ y₁ = y₂) → ·(x₁, y₁) = ·(x₂, y₂))`
    我们需要对任意 `[t₁], [u₁], [t₂], [u₂] ∈ Uₘ`，验证 `M ⊨ ([t₁]=[t₂] ∧ [u₁]=[u₂]) → ·ᴹ([t₁],[u₁]) = ·ᴹ([t₂],[u₂])`。
    假设 `M ⊨ [t₁]=[t₂]` 且 `M ⊨ [u₁]=[u₂]`，即 `[t₁]=[t₂]` 且 `[u₁]=[u₂]`。
    根据 `·ᴹ` 的定义，`·ᴹ([t₁],[u₁]) = [·(t₁,u₁)]` 且 `·ᴹ([t₂],[u₂]) = [·(t₂,u₂)]`。
    因为 `[t₁]=[t₂]` 意味着 `t₁ ~ t₂`，`[u₁]=[u₂]` 意味着 `u₁ ~ u₂`。
    由于 `~` 是一个同余关系 (引理 2.2.1)，`t₁ ~ t₂` 且 `u₁ ~ u₂` 蕴含 `·(t₁, u₁) ~ ·(t₂, u₂)`。
    这反过来意味着 `[·(t₁, u₁)] = [·(t₂, u₂)]`。
    因此 `·ᴹ([t₁],[u₁]) = ·ᴹ([t₂],[u₂])`。
    该公理在 `M` 中为真。

3.  **非逻辑公理的验证 (以 A1 为例):**
    `∀a (equiv(a, a) = 1)`
    我们需要对任意 `[t] ∈ Uₘ`，验证 `equivᴹ([t], [t]) = 1ᴹ`。
    `equivᴹ([t], [t]) = [equiv(t, t)]` (根据 `equivᴹ` 定义)。
    `1ᴹ = [1]` (根据 `1ᴹ` 定义)。
    所以我们需要验证 `[equiv(t, t)] = [1]`，这等价于 `equiv(t, t) ~ 1`。
    根据 `~` 的定义，这等价于 `Tₑ ⊢ equiv(t, t) = 1`。
    公理 `∀a (equiv(a, a) = 1)` 是 **Tₑ** 的公理，通过全称实例化 (Universal Instantiation)，用项 `t` 替换 `a`，即可得到 `Tₑ ⊢ equiv(t, t) = 1`。
    因此，公理 A1 在 `M` 中为真。

对公理 A2, A3, A4 的验证与 A1 完全类似，它们在 `M` 中的真值最终都归结为 `Tₑ` 中对应的可证性，而这些可证性由公理本身保证。由于 **Tₑ** 的所有公理都在 `M` 中为真，故 `M` 是 **Tₑ** 的一个模型。**定理证毕。**

**定理 3.2.2:** 理论 **Tₑ** 是相容的 (consistent)。
**证明:**
1.  根据定理 3.2.1，理论 **Tₑ** 拥有一个模型 `M`。
2.  在 4.1 节中，我们将证明 `M` 的论域 `Uₘ` 包含多于一个元素。具体来说，将证明存在两个无变量项 `t₁, t₂` (即 `g₀` 和 `1`) 使得 `[t₁] ≠ [t₂]`。
3.  `[t₁] ≠ [t₂]` 意味着 `t₁ᴹ ≠ t₂ᴹ`，这等价于 `M ⊭ t₁ = t₂`。
4.  根据可靠性 (`⇒` 方向) 定理 3.1.2 的逆否命题，`M ⊭ t₁ = t₂` 蕴含 `Tₑ ⊬ t₁ = t₂`。
5.  一个理论，如果存在它无法证明的公式 (例如 `t₁ = t₂`)，那么它就是相容的。因为如果它不相容，它将能够证明所有公式。
因此，**Tₑ** 是相容的。**定理证毕。**

### **4. 模型 M 的性质证明**

**核心方法：不变量原理**

为证明两个无变量项 `t₁` 和 `t₂` 在 `M` 中不等价，即 `[t₁] ≠ [t₂]`，根据定理 3.1.2，等价于证明 `Tₑ ⊬ t₁ = t₂`。我们采用不变量方法。一个函数 `f`（其值域不限）被称为 **Tₑ-等价不变量**，如果它满足以下条件：
对于任意两个无变量项 `u, v ∈ T`，若 `Tₑ ⊢ u = v`，则 `f(u) = f(v)`。

**不变量原理:** 若 `f` 是一个 **Tₑ**-等价不变量，且存在两个无变量项 `t₁, t₂` 使得 `f(t₁) ≠ f(t₂)`，则可以断定 `Tₑ ⊬ t₁ = t₂`，从而 `[t₁] ≠ [t₂]`。

要证明一个函数 `f` 是 **Tₑ**-等价不变量，必须通过对 **Tₑ** 中等式证明的长度进行归纳来证明。这等价于验证 `f` 的值在所有产生等式的基本公理和推理步骤下保持不变：
1.  **逻辑公理:**
    *   **自反性:** 对任意项 `t`，`f(t) = f(t)` 必须成立 (平凡)。
    *   **对称性:** 若 `f(u)=f(v)`，则 `f(v)=f(u)` 必须成立 (平凡)。
    *   **传递性:** 若 `f(u)=f(v)` 且 `f(v)=f(w)`，则 `f(u)=f(w)` 必须成立 (平凡)。
    *   **同余性 (Congruence):** 这是最关键的条件。必须验证：
        *   若 `f(u₁)=f(u₂)` 且 `f(v₁)=f(v₂)`，则必须有 `f(·(u₁, v₁)) = f(·(u₂, v₂))`。
        *   若 `f(u₁)=f(u₂)` 且 `f(v₁)=f(v₂)`，则必须有 `f(equiv(u₁, v₁)) = f(equiv(u₂, v₂))`。

2.  **非逻辑公理:**
    *   对于 **Tₑ** 的每个非逻辑公理 `∀v₁...∀vₙ (u = v)`，必须验证对于基域 `T` 中项的任意代入，该等式两边的 `f` 值相等。即，对于任意 `t₁,...,tₙ ∈ T`，`f(u[t₁/v₁,...,tₙ/vₙ]) = f(v[t₁/v₁,...,tₙ/vₙ])` 必须成立。

只有满足以上所有条件，`f` 才是一个有效的不变量。

#### **4.1. M 是非平凡的 (Non-trivial)**
**命题:** `Uₘ` 包含多于一个元素。
**证明:** 我们证明 `[g₀] ≠ [1]`。定义函数 `f: T → {true, false}` 如下：
`f(t) = true` 如果 `t` 是一个生成元 `gᵢ ∈ G`。
`f(t) = false` 对于所有其他情况 (即 `t` 是常量 `1` 或任何复合项)。

我们现在遵循不变量原理证明 `f` 是一个 **Tₑ**-等价不变量。

1.  **逻辑公理验证:**
    *   **同余性:**
        *   假设 `f(u₁)=f(u₂)` 且 `f(v₁)=f(v₂)`。考虑项 `·(u₁, v₁)` 和 `·(u₂, v₂)`。根据 `f` 的定义，任何以 `·` 为主函数符号的项，其 `f` 值均为 `false`。因此 `f(·(u₁, v₁)) = false` 且 `f(·(u₂, v₂)) = false`。故 `f(·(u₁, v₁)) = f(·(u₂, v₂))`。
        *   `equiv` 函数的同余性同理可证。

2.  **非逻辑公理验证:** 我们对任意 `t₁, t₂ ∈ T` 验证公理实例。
    *   **A1 `equiv(t₁, t₁) = 1`:**
        `f(equiv(t₁, t₁)) = false` (因为是复合项)。
        `f(1) = false` (因为是常量 `1`)。
        `f` 值相等，保持。
    *   **A2 `equiv(t₁, t₂) = equiv(t₂, t₁)`:**
        `f(equiv(t₁, t₂)) = false`。
        `f(equiv(t₂, t₁)) = false`。
        `f` 值相等，保持。
    *   **A3, A4:** 等式两边均为复合项，其 `f` 值都为 `false`。保持。

由于 `f` 满足所有条件，它是一个 **Tₑ**-等价不变量。

**区分性:**
*   `f(g₀) = true` (根据定义)。
*   `f(1) = false` (根据定义)。
由于 `f(g₀) ≠ f(1)`，根据不变量原理，我们得出 `Tₑ ⊬ g₀ = 1`。
因此，`g₀ ≁ 1`，故 `[g₀] ≠ [1]`。这意味着 `Uₘ` 至少包含两个不同的元素。**命题证毕。**

#### **4.2. M 是无限的 (Infinite)**
**命题:** `Uₘ` 是一个无限集。
**证明:** 我们将证明对于任意 `i ≠ j`，`[gᵢ] ≠ [gⱼ]`。这表明集合 `{[gₖ] | k ∈ ℕ}` 是 `Uₘ` 的一个可数无限子集。
对于每个 `k ∈ ℕ`，定义函数 `pₖ: T → {0, 1}` 如下：
`pₖ(t) = count(gₖ, t) mod 2`，其中 `count(gₖ, t)` 是生成元 `gₖ` 在项 `t` 中出现的次数。
此定义可归纳地表述为：
*   `pₖ(1) = 0`
*   `pₖ(gᵢ) = 1` 如果 `i=k`；`pₖ(gᵢ) = 0` 如果 `i≠k`。
*   `pₖ(·(u, v)) = (pₖ(u) + pₖ(v)) mod 2`
*   `pₖ(equiv(u, v)) = (pₖ(u) + pₖ(v)) mod 2`

我们证明对于任意 `k`，`pₖ` 都是一个 **Tₑ**-等价不变量。

1.  **逻辑公理验证:**
    *   **同余性:**
        *   假设 `pₖ(u₁)=pₖ(u₂)` 且 `pₖ(v₁)=pₖ(v₂)`。
        *   `pₖ(·(u₁, v₁)) = (pₖ(u₁) + pₖ(v₁)) mod 2`。
        *   `pₖ(·(u₂, v₂)) = (pₖ(u₂) + pₖ(v₂)) mod 2`。
        *   根据假设，两表达式相等。故 `pₖ` 对 `·` 保持同余。
        *   `equiv` 函数的同余性同理可证。

2.  **非逻辑公理验证:** 我们对任意代入项 `t₁, t₂, t₃ ∈ T` 验证。
    *   **A1 `equiv(t₁, t₁) = 1`:**
        `pₖ(equiv(t₁, t₁)) = (pₖ(t₁) + pₖ(t₁)) mod 2 = (2 * pₖ(t₁)) mod 2 = 0`。
        `pₖ(1) = 0`。
        `pₖ` 值相等，保持。
    *   **A2 `equiv(t₁, t₂) = equiv(t₂, t₁)`:**
        `pₖ(LHS) = (pₖ(t₁) + pₖ(t₂)) mod 2`。
        `pₖ(RHS) = (pₖ(t₂) + pₖ(t₁)) mod 2`。
        `pₖ` 值相等，保持。
    *   **A3 `equiv(·(t₁, t₂), t₃) = ·(t₃, equiv(t₁, t₂))`:**
        `pₖ(LHS) = (pₖ(·(t₁, t₂)) + pₖ(t₃)) mod 2 = (pₖ(t₁) + pₖ(t₂) + pₖ(t₃)) mod 2`。
        `pₖ(RHS) = (pₖ(t₃) + pₖ(equiv(t₁, t₂))) mod 2 = (pₖ(t₃) + pₖ(t₁) + pₖ(t₂)) mod 2`。
        `pₖ` 值相等，保持。
    *   **A4:** 与 A3 对称，同理保持。

`pₖ` 是一个 **Tₑ**-等价不变量。

**区分性:**
考虑任意两个不同的自然数 `i, j`。我们使用不变量 `pᵢ` 来区分 `gᵢ` 和 `gⱼ`。
*   `pᵢ(gᵢ) = 1`。
*   `pᵢ(gⱼ) = 0` (因为 `i ≠ j`)。
由于 `pᵢ(gᵢ) ≠ pᵢ(gⱼ)`，根据不变量原理，`Tₑ ⊬ gᵢ = gⱼ`。
这对于任意 `i ≠ j` 均成立，因此 `[gᵢ] ≠ [gⱼ]`。这意味着集合 `{[g₀], [g₁], [g₂], ...}` 是 `Uₘ` 的一个无限子集。故 `Uₘ` 是无限集。**命题证毕。**

---

### **5. 内定理 (Internal Theorems)**

本节将在形式系统 **Tₑ** 内部，仅使用其公理和推理规则，推导出一系列可证定理。

---

#### **定理 5.1: `equiv` 项的交换律 (Commutativity of `equiv`-terms)**

**定理陈述:** `Tₑ ⊢ ∀a ∀b ∀x (·(x, equiv(a, b)) = ·(equiv(a, b), x))`

**证明:**

1.  `Tₑ ⊢ ∀a ∀b ∀x (equiv(·(a, b), x) = ·(x, equiv(a, b)))`
    *   来源: 公理 **(A3)**。

2.  `Tₑ ⊢ equiv(·(a, b), x) = ·(x, equiv(a, b))`
    *   来源: 从 (1) 进行全称实例化。

3.  `Tₑ ⊢ ∀a' ∀b' (equiv(a', b') = equiv(b', a'))`
    *   来源: 公理 **(A2)**。

4.  `Tₑ ⊢ equiv(·(a, b), x) = equiv(x, ·(a, b))`
    *   来源: 从 (3) 进行全称实例化，令 `a' = ·(a, b)` 且 `b' = x`。

5.  `Tₑ ⊢ ·(x, equiv(a, b)) = equiv(x, ·(a, b))`
    *   来源: 从 (2) 和 (4)，根据 ` = ` 的对称性和传递性。

6.  `Tₑ ⊢ ∀a ∀b ∀x (equiv(x, ·(a, b)) = ·(equiv(a, b), x))`
    *   来源: 公理 **(A4)**。

7.  `Tₑ ⊢ equiv(x, ·(a, b)) = ·(equiv(a, b), x)`
    *   来源: 从 (6) 进行全称实例化。

8.  `Tₑ ⊢ ·(x, equiv(a, b)) = ·(equiv(a, b), x)`
    *   来源: 从 (5) 和 (7)，根据 ` = ` 的传递性。

9.  `Tₑ ⊢ ∀a ∀b ∀x (·(x, equiv(a, b)) = ·(equiv(a, b), x))`
    *   来源: 对 (8) 应用泛化规则 (Generalization) 三次 (对变量 `a`, `b`, `x`)。

**证毕。**

---

#### **定理 5.2: 常量 `1` 的交换律 (Commutativity of `1`)**

**定理陈述:** `Tₑ ⊢ ∀x (·(x, 1) = ·(1, x))`

**证明:**

1.  `Tₑ ⊢ ∀a ∀b ∀x (·(x, equiv(a, b)) = ·(equiv(a, b), x))`
    *   来源: **定理 5.1**。

2.  `Tₑ ⊢ ∀a ∀x (·(x, equiv(a, a)) = ·(equiv(a, a), x))`
    *   来源: 从 (1) 进行全称实例化，令 `b = a`。

3.  `Tₑ ⊢ ∀a (equiv(a, a) = 1)`
    *   来源: 公理 **(A1)**。

4.  `Tₑ ⊢ ·(x, 1) = ·(1, x)`
    *   来源: 在 (2) 的全称实例 `·(x, equiv(a, a)) = ·(equiv(a, a), x)` 中，使用 (3) 的全称实例 `equiv(a, a) = 1` 进行等价替换。

5.  `Tₑ ⊢ ∀x (·(x, 1) = ·(1, x))`
    *   来源: 对 (4) 应用泛化规则 (对变量 `x`)。

**证毕。**


---

#### **定理 5.3: 四元交互律 (Four-Term Interaction Law)**

**定理陈述:** `Tₑ ⊢ ∀a ∀b ∀c ∀d (·(·(c, d), equiv(a, b)) = ·(equiv(c, d), ·(a, b)))`

**证明:**

1.  `Tₑ ⊢ ∀a' ∀b' ∀x (equiv(·(a', b'), x) = ·(x, equiv(a', b')))`
    *   来源: 公理 **(A3)**。

2.  `Tₑ ⊢ equiv(·(a, b), ·(c, d)) = ·(·(c, d), equiv(a, b))`
    *   来源: 从 (1) 进行全称实例化，令 `a' = a`, `b' = b`, `x = ·(c, d)`。

3.  `Tₑ ⊢ ∀a' ∀b' ∀x (equiv(x, ·(a', b')) = ·(equiv(a', b'), x))`
    *   来源: 公理 **(A4)**。

4.  `Tₑ ⊢ equiv(·(a, b), ·(c, d)) = ·(equiv(c, d), ·(a, b))`
    *   来源: 从 (3) 进行全称实例化，令 `a' = c`, `b' = d`, `x = ·(a, b)`。

5.  `Tₑ ⊢ ·(·(c, d), equiv(a, b)) = ·(equiv(c, d), ·(a, b))`
    *   来源: 从 (2) 和 (4)，根据 ` = ` 的对称性和传递性。

6.  `Tₑ ⊢ ∀a ∀b ∀c ∀d (·(·(c, d), equiv(a, b)) = ·(equiv(c, d), ·(a, b)))`
    *   来源: 对 (5) 应用泛化规则 (对变量 `a`, `b`, `c`, `d`)。

**证毕。**

---

#### **定理 5.4: 平方项交互律 (Square Interaction Law)**

**定理陈述:** `Tₑ ⊢ ∀a ∀b ∀c (·(·(c, c), equiv(a, b)) = ·(1, ·(a, b)))`

**证明:**

1.  `Tₑ ⊢ ∀a ∀b ∀c ∀d (·(·(c, d), equiv(a, b)) = ·(equiv(c, d), ·(a, b)))`
    *   来源: **定理 5.3**。

2.  `Tₑ ⊢ ·(·(c, c), equiv(a, b)) = ·(equiv(c, c), ·(a, b))`
    *   来源: 从 (1) 进行全称实例化，令 `d = c`。

3.  `Tₑ ⊢ ∀x (equiv(x, x) = 1)`
    *   来源: 公理 **(A1)**。

4.  `Tₑ ⊢ equiv(c, c) = 1`
    *   来源: 从 (3) 进行全称实例化，令 `x = c`。

5.  `Tₑ ⊢ ·(·(c, c), equiv(a, b)) = ·(1, ·(a, b))`
    *   来源: 在 (2) 的右侧，使用 (4) 进行等价替换。

6.  `Tₑ ⊢ ∀a ∀b ∀c (·(·(c, c), equiv(a, b)) = ·(1, ·(a, b)))`
    *   来源: 对 (5) 应用泛化规则 (对变量 `a`, `b`, `c`)。

**证毕。**

---

#### **定理 5.5: `equiv` 复合律 (A Composition Law for `equiv`)**

**定理陈述:** `Tₑ ⊢ ∀a ∀b ∀x (·(equiv(a, b), x) = equiv(x, ·(a, b)))`

**证明:**

1.  `Tₑ ⊢ ∀a ∀b ∀x (equiv(x, ·(a, b)) = ·(equiv(a, b), x))`
    *   来源: 公理 **(A4)**。

2.  `Tₑ ⊢ equiv(x, ·(a, b)) = ·(equiv(a, b), x)`
    *   来源: 从 (1) 进行全称实例化。

3.  `Tₑ ⊢ ·(equiv(a, b), x) = equiv(x, ·(a, b))`
    *   来源: 从 (2) 应用 ` = ` 的对称性。

4.  `Tₑ ⊢ ∀a ∀b ∀x (·(equiv(a, b), x) = equiv(x, ·(a, b)))`
    *   来源: 对 (3) 应用泛化规则 (对变量 `a`, `b`, `x`)。

**证毕。**

#### **定理 5.6: `1` 在 `·` 运算下的部分吸收律**

**定理陈述:** `Tₑ ⊢ ∀a ∀c ∀d (·(·(c, d), 1) = ·(equiv(c, d), ·(a, a)))`

**证明:**

1.  `Tₑ ⊢ ∀a ∀b ∀c ∀d (·(·(c, d), equiv(a, b)) = ·(equiv(c, d), ·(a, b)))`
    *   来源: **定理 5.3**。

2.  `Tₑ ⊢ ·(·(c, d), equiv(a, a)) = ·(equiv(c, d), ·(a, a))`
    *   来源: 从 (1) 进行全称实例化，令 `b = a`。

3.  `Tₑ ⊢ ∀x (equiv(x, x) = 1)`
    *   来源: 公理 **(A1)**。

4.  `Tₑ ⊢ equiv(a, a) = 1`
    *   来源: 从 (3) 进行全称实例化，令 `x = a`。

5.  `Tₑ ⊢ ·(·(c, d), 1) = ·(equiv(c, d), ·(a, a))`
    *   来源: 在 (2) 的左侧，使用 (4) 进行等价替换。

6.  `Tₑ ⊢ ∀a ∀c ∀d (·(·(c, d), 1) = ·(equiv(c, d), ·(a, a)))`
    *   来源: 对 (5) 应用泛化规则 (对变量 `a`, `c`, `d`)。

**证毕。**

---

#### **定理 5.7: “平方项”的等价性**

**定理陈述:** `Tₑ ⊢ ∀a ∀c (·(1, ·(a, a)) = ·(1, ·(c, c)))`

**证明:**

1.  `Tₑ ⊢ ∀a ∀c ∀d (·(·(c, d), 1) = ·(equiv(c, d), ·(a, a)))`
    *   来源: **定理 5.6**。

2.  `Tₑ ⊢ ·(·(c, c), 1) = ·(equiv(c, c), ·(a, a))`
    *   来源: 从 (1) 进行全称实例化，令 `d = c`。

3.  `Tₑ ⊢ equiv(c, c) = 1`
    *   来源: 公理 **(A1)** 的实例。

4.  `Tₑ ⊢ ·(·(c, c), 1) = ·(1, ·(a, a))`
    *   来源: 在 (2) 的右侧，使用 (3) 进行等价替换。

5.  `Tₑ ⊢ ∀x (·(x, 1) = ·(1, x))`
    *   来源: **定理 5.2**。

6.  `Tₑ ⊢ ·(·(c, c), 1) = ·(1, ·(c, c))`
    *   来源: 从 (5) 进行全称实例化，令 `x = ·(c, c)`。

7.  `Tₑ ⊢ ·(1, ·(c, c)) = ·(1, ·(a, a))`
    *   来源: 从 (4) 和 (6)，根据 ` = ` 的对称性和传递性。

8.  `Tₑ ⊢ ∀a ∀c (·(1, ·(a, a)) = ·(1, ·(c, c)))`
    *   来源: 对 (7) 应用泛化规则 (对变量 `a`, `c`)。

**证毕。**

**定义:** 令 `K` 作为项 `·(1, ·(1, 1))` 的宏。根据定理 5.7，我们有 `Tₑ ⊢ ∀x (·(1, ·(x, x)) = K)`。

---

#### **定理 5.8: “平方项”与 `1` 结合的交换律**

**定理陈述:** `Tₑ ⊢ ∀x (·(·(x, x), 1) = K)` (其中 `K` 是 `·(1, ·(1, 1))` 的宏)

**证明:**

1.  `Tₑ ⊢ ·(·(c, c), 1) = ·(1, ·(a, a))` (来自定理 5.7 的证明步骤 4)
    *   这是一个对任意 `a, c` 成立的可证公式。

2.  `Tₑ ⊢ ·(·(x, x), 1) = ·(1, ·(1, 1))`
    *   来源: 在 (1) 中，令 `c=x` 且 `a=1`。

3.  `Tₑ ⊢ ·(·(x, x), 1) = K`
    *   来源: 根据 `K` 的定义进行替换。

4.  `Tₑ ⊢ ∀x (·(·(x, x), 1) = K)`
    *   来源: 对 (3) 应用泛化规则 (对变量 `x`)。

**证毕。**

---

#### **定理 5.9: `equiv` 项的交换律 (在 `·` 运算下)**

**定理陈述:** `Tₑ ⊢ ∀a ∀b ∀c ∀d (·(equiv(a, b), equiv(c, d)) = ·(equiv(c, d), equiv(a, b)))`

**证明:**

1.  `Tₑ ⊢ ∀a' ∀b' ∀x (·(x, equiv(a', b')) = ·(equiv(a', b'), x))`
    *   来源: **定理 5.1**。

2.  `Tₑ ⊢ ·(equiv(c, d), equiv(a, b)) = ·(equiv(a, b), equiv(c, d))`
    *   来源: 从 (1) 进行全称实例化，令 `x = equiv(c, d)`, `a' = a`, `b' = b`。

3.  `Tₑ ⊢ ·(equiv(a, b), equiv(c, d)) = ·(equiv(c, d), equiv(a, b))`
    *   来源: 从 (2) 应用 ` = ` 的对称性。

4.  `Tₑ ⊢ ∀a ∀b ∀c ∀d (·(equiv(a, b), equiv(c, d)) = ·(equiv(c, d), equiv(a, b)))`
    *   来源: 对 (3) 应用泛化规则。

**证毕。**

---

#### **定理 5.10: `equiv` 的一个三重嵌套恒等式**

**定理陈述:** `Tₑ ⊢ ∀a ∀b ∀c ∀d (equiv(·(a, b), equiv(c, d)) = ·(equiv(c, d), equiv(a, b)))`

**证明:**

1.  `Tₑ ⊢ ∀a' ∀b' ∀x (equiv(·(a', b'), x) = ·(x, equiv(a', b')))`
    *   来源: 公理 **(A3)**。

2.  `Tₑ ⊢ equiv(·(a, b), equiv(c, d)) = ·(equiv(c, d), equiv(a, b))`
    *   来源: 从 (1) 进行全称实例化，令 `a' = a`, `b' = b`, `x = equiv(c, d)`。

3.  `Tₑ ⊢ ∀a ∀b ∀c ∀d (equiv(·(a, b), equiv(c, d)) = ·(equiv(c, d), equiv(a, b)))`
    *   来源: 对 (2) 应用泛化规则。

**证毕。**

---

#### **定理 5.11: `·` 与 `equiv` 的核心连接**

**定理陈述:** `Tₑ ⊢ ∀a ∀x (·(1, x) = equiv(x, ·(a, a)))`

**证明:**

1.  `Tₑ ⊢ ∀a' ∀b' ∀y (·(equiv(a', b'), y) = equiv(y, ·(a', b')))`
    *   来源: **定理 5.5** (变量重命名)。

2.  `Tₑ ⊢ ·(equiv(a, a), x) = equiv(x, ·(a, a))`
    *   来源: 从 (1) 进行全称实例化，令 `a' = a`, `b' = a`, `y = x`。

3.  `Tₑ ⊢ ∀z (equiv(z, z) = 1)`
    *   来源: 公理 **(A1)** (变量重命名)。

4.  `Tₑ ⊢ equiv(a, a) = 1`
    *   来源: 从 (3) 进行全称实例化，令 `z = a`。

5.  `Tₑ ⊢ ·(1, x) = equiv(x, ·(a, a))`
    *   来源: 在 (2) 的左侧，使用 (4) 的等式进行等价替换。

6.  `Tₑ ⊢ ∀a ∀x (·(1, x) = equiv(x, ·(a, a)))`
    *   来源: 对 (5) 应用泛化规则 (对变量 `a` 和 `x`)。

**证毕。**

---

#### **定理 5.12: 所有“平方项”之间的 `equiv` 值**

**定理陈述:** `Tₑ ⊢ ∀a ∀b (equiv(·(b, b), ·(a, a)) = K)`

**证明:**

1.  `Tₑ ⊢ ∀a' ∀x (·(1, x) = equiv(x, ·(a', a')))`
    *   来源: **定理 5.11** (变量重命名)。

2.  `Tₑ ⊢ ·(1, ·(b, b)) = equiv(·(b, b), ·(a, a))`
    *   来源: 从 (1) 进行全称实例化，令 `x = ·(b, b)` 和 `a' = a`。

3.  `Tₑ ⊢ ∀y (·(1, ·(y, y)) = K)`
    *   来源: **定理 5.7** 的推论及 `K` 的定义 (变量重命名)。

4.  `Tₑ ⊢ ·(1, ·(b, b)) = K`
    *   来源: 从 (3) 进行全称实例化，令 `y = b`。

5.  `Tₑ ⊢ equiv(·(b, b), ·(a, a)) = K`
    *   来源: 从 (2) 和 (4)，根据 ` = ` 的对称性和传递性。

6.  `Tₑ ⊢ ∀a ∀b (equiv(·(b, b), ·(a, a)) = K)`
    *   来源: 对 (5) 应用泛化规则 (对变量 `a` 和 `b`)。

**证毕。**

---

#### **定理 5.13: 核心常量 `K` 的简化**

**定理陈述:** `Tₑ ⊢ K = 1`

**证明:**

1.  `Tₑ ⊢ ∀a ∀b (equiv(·(b, b), ·(a, a)) = K)`
    *   来源: **定理 5.12**。

2.  `Tₑ ⊢ equiv(·(a, a), ·(a, a)) = K`
    *   来源: 从 (1) 进行全称实例化，令 `b = a`。

3.  `Tₑ ⊢ ∀x (equiv(x, x) = 1)`
    *   来源: 公理 **(A1)**。

4.  `Tₑ ⊢ equiv(·(a, a), ·(a, a)) = 1`
    *   来源: 从 (3) 进行全称实例化，令 `x = ·(a, a)`。

5.  `Tₑ ⊢ K = 1`
    *   来源: 从 (2) 和 (4)，根据 ` = ` 的传递性。

**证毕。**

---

#### **推论 5.14: 理论的简化**

**推论 5.14.1:** `Tₑ ⊢ ∀x (·(·(x, x), 1) = 1)`

**证明:**

1.  `Tₑ ⊢ ∀x (·(·(x, x), 1) = K)`
    *   来源: **定理 5.8**。

2.  `Tₑ ⊢ K = 1`
    *   来源: **定理 5.13**。

3.  `Tₑ ⊢ ∀x (·(·(x, x), 1) = 1)`
    *   来源: 在 (1) 中使用 (2) 的等式进行替换。

**证毕。**

**推论 5.14.2:** `Tₑ ⊢ ∀x (·(1, ·(x, x)) = 1)`

**证明:**

1.  `Tₑ ⊢ ∀x (·(1, ·(x, x)) = K)`
    *   来源: **定理 5.7** 的推论及 `K` 的定义。

2.  `Tₑ ⊢ K = 1`
    *   来源: **定理 5.13**。

3.  `Tₑ ⊢ ∀x (·(1, ·(x, x)) = 1)`
    *   来源: 在 (1) 中使用 (2) 的等式进行替换。

**证毕。**

**推论 5.14.3:** `Tₑ ⊢ ∀a ∀b (equiv(·(a, a), ·(b, b)) = 1)`

**证明:**

1.  `Tₑ ⊢ ∀a ∀b (equiv(·(a, a), ·(b, b)) = K)`
    *   来源: **定理 5.12** (变量 `a`,`b` 交换)。

2.  `Tₑ ⊢ K = 1`
    *   来源: **定理 5.13**。

3.  `Tₑ ⊢ ∀a ∀b (equiv(·(a, a), ·(b, b)) = 1)`
    *   来源: 在 (1) 中使用 (2) 的等式进行替换。

**证毕。**