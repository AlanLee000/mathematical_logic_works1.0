### **形式系统 HCL (Hierarchical Context Logic)**

#### **1. 语法 (Syntax)**

**1.1. 基础集合 (Primitive Sets)**

*   **`A`**: 一个可数的**原子 (Atom)** 集合。
*   **`C`**: 一个**复合构造符 (Compound Constructors)** 的集合。每个构造符 `c ∈ C` 都有一个固定的元数（arity）`ar(c) ∈ ℕ⁺`。我们假定 `C` 中包含一个元数为 2 的特定构造符，记作 `→`，用于表示蕴含。
*   **`Quote`**: 一个特殊的**引用构造符 (Quoting Constructor)**。

**1.2. 公式 (Formulas)**

**公式集合 `U`** 是满足以下条件的最小集合：
1.  **原子**: 如果 `a ∈ A`，则 `a ∈ U`。
2.  **复合**: 如果 `c ∈ C` 且 `ar(c) = n`，并且 `u₁, u₂, ..., uₙ ∈ U`，则 `c(u₁, u₂, ..., uₙ) ∈ U`。
    *   **表示约定**: 对于元数为 2 的特定构造符 `→`，我们将 `→(u₁, u₂)` 写作 `(u₁ → u₂)`。
3.  **引用**: 如果 `S` 是一个公式序列（见 1.3），则 `Quote(S) ∈ U`。

**1.3. 公式序列 (Sequences of Formulas)**

**公式序列集合 `Seq(U)`** 被定义为 `U` 中元素的所有有限有序元组的集合：
`Seq(U) = { (u₁, u₂, ..., uₖ) | k ≥ 0 ∧ ∀i (1 ≤ i ≤ k ⇒ uᵢ ∈ U) }`
空序列 `()` 也是 `Seq(U)` 的一个元素。

#### **2. 上下文结构 (Context Structure)**

**2.1. 上下文树 (Context Tree)**

一个**上下文树 `Ξ`** 是一个三元组 `(N, E, C)`，其中：
*   `N`: 一个有限的**节点 (Nodes)** 集合。
*   `E`: 一个**边 (Edges)** 集合 `E ⊆ N × N`，使得图 `(N, E)` 构成一个有根树。`(p, c) ∈ E` 表示 `p` 是 `c` 的父节点。
*   `C`: 一个**内容函数 (Content Function)** `C: N → Seq(U)`，为每个节点分配一个公式序列。

**2.2. 祖先关系 (Ancestor Relation)**

我们定义节点间的**祖先关系 `>`** 如下：
`p > n` 当且仅当存在一个从 `p` 到 `n` 的、长度至少为 1 的路径。即，`>` 是边关系 `E` 的传递闭包。

#### **3. 判断 (Judgment)**

本系统只有一个判断形式：
` (Ξ, n) ⊢ u `
其中：
*   `Ξ` 是一个上下文树。
*   `n` 是 `Ξ` 中的一个节点。
*   `⊢` 是**可推导关系 (Derivability Relation)** 的符号。
*   `u` 是一个公式。

此判断读作：“公式 `u` 在上下文树 `Ξ` 的节点 `n` 中是可推导的”。

#### **4. 推导系统 (Derivation System)**

可推导关系 `⊢` 是由以下公理和推理规则归纳定义的最小关系。

**4.1. 辅助函数**

*   `elements(S)`: 对于一个序列 `S = (u₁, ..., uₖ)`，`elements(S)` 返回其元素的集合 `{u₁, ..., uₖ}`。`elements(()) = ∅`。

**4.2. 公理与规则**

**公理 1: 访问公理 (Axiom of Access)**
$$ \frac{u \in \text{elements}(C(n))}{(\Xi, n) \vdash u} $$

**规则 2: 继承规则 (Rule of Inheritance)**
$$ \frac{(\Xi, p) \vdash u \quad p > n}{(\Xi, n) \vdash u} $$

**规则 3: 蕴含消除规则 (Rule of Implication Elimination / Modus Ponens)**
$$ \frac{(\Xi, n) \vdash (u_1 \to u_2) \quad (\Xi, n) \vdash u_1}{(\Xi, n) \vdash u_2} $$

**公理 4: 空引用公理 (Axiom of Empty Quote)**
$$ \overline{(\Xi, n) \vdash \text{Quote}(())} $$

**规则 5: 引用引入规则 (Rule of Quote Introduction)**
$$ \frac{\forall u_i \in \text{elements}(S), \ (\Xi, n) \vdash u_i}{(\Xi, n) \vdash \text{Quote}(S)} \quad (S \neq ()) $$

---

### **5. 模型论语义 (Model-Theoretic Semantics)**

#### **5.1. 克里普克-HCL 模型 (Kripke-HCL Model)**

一个**克里普克-HCL 模型** `M` 是一个三元组 `M = (Ξ, R, V)`，其构成如下：

*   **`Ξ`**: 一个上下文树 `(N, E, C)`。集合 `N` 作为**可能世界 (Possible Worlds)** 的集合。
*   **`R`**: 一个在 `N` 上的**可达关系 (Accessibility Relation)**，由祖先关系定义，即 `R = { (p, n) ∈ N × N | p > n }`。
*   **`V`**: 一个**赋值函数 (Valuation Function)**，`V: N × A → {True, False}`，为每个世界 `n ∈ N` 中的每个原子 `a ∈ A` 分配一个真值。

#### **5.2. 满足关系 (Satisfaction Relation)**

公式 `u` 在模型 `M` 的世界 `n` 中为真，记作 `M, n ⊨ u`。该关系通过对 `u` 的结构进行归纳定义如下：

1.  **原子公式**:
    `M, n ⊨ a` 当且仅当 `V(n, a) = True`，其中 `a ∈ A`。

2.  **复合公式**:
    *   **蕴含 (`→`)**: `M, n ⊨ (u₁ → u₂)` 当且仅当 `(M, n ⊨ u₁)` 蕴含 `(M, n ⊨ u₂)`。（注：此处的“蕴含”是元语言中的实质蕴含）。
    *   对于 `C` 中其他元数为 `k` 的构造符 `c`，其语义规则 `M, n ⊨ c(u₁, ..., uₖ)` 需另行指定。

3.  **引用公式**:
    `M, n ⊨ Quote(S)` 当且仅当对于所有 `uᵢ ∈ elements(S)` 以及所有 `n' ∈ N`，若 `(n, n') ∈ R`，则 `M, n' ⊨ uᵢ`。

#### **5.3. 有效性与语义推论 (Validity and Semantic Consequence)**

*   一个克里普克-HCL 模型 `M = (Ξ, R, V)` 是**有效的 (valid)**，当且仅当它满足以下两个条件：
    1.  **公理为真 (Axiom Validity)**: 对于所有 `n ∈ N` 和所有 `u ∈ elements(C(n))`，均有 `M, n ⊨ u`。
    2.  **继承为真 (Inheritance Validity)**: 对于所有 `(p, n) ∈ R`，以及所有公式 `u ∈ U`，若 `M, p ⊨ u`，则 `M, n ⊨ u`。

*   公式 `u` 是在上下文树 `Ξ` 的节点 `n` 上的一个**语义推论 (semantic consequence)**，记作 `Ξ ⊨ u @ n`，当且仅当对于所有基于 `Ξ` 的**有效**克里普克-HCL 模型 `M`，均有 `M, n ⊨ u`。

---

### **6. 可靠性与一致性证明**

#### **6.1. 可靠性定理 (Soundness Theorem)**

**定理**: HCL 系统是可靠的。即，如果 `(Ξ, n) ⊢ u`，则 `Ξ ⊨ u @ n`。

**证明**: 对推导 `(Ξ, n) ⊢ u` 的长度 `k` 进行数学归纳法。

*   **基础情况 (k=1)**: 推导由公理直接得出。

    *   **情况 1.1: 访问公理 (公理 1)**
        1.  前提：`(Ξ, n) ⊢ u` 由 `u ∈ elements(C(n))` 得出。
        2.  令 `M` 为任意一个基于 `Ξ` 的有效模型。
        3.  根据有效模型的**公理为真**条件，对于所有 `v ∈ elements(C(n))`，必有 `M, n ⊨ v`。
        4.  因此，`M, n ⊨ u`。
        5.  由于 `M` 是任意的，根据语义推论的定义，`Ξ ⊨ u @ n`。

    *   **情况 1.2: 空引用公理 (公理 4)**
        1.  前提：`(Ξ, n) ⊢ Quote(())` 由该公理得出。
        2.  令 `M` 为任意一个基于 `Ξ` 的有效模型。我们需要证明 `M, n ⊨ Quote(())`。
        3.  根据满足关系定义，`M, n ⊨ Quote(())` 当且仅当 `∀uᵢ ∈ elements(()), ∀n' ∈ N, ((n, n') ∈ R ⇒ M, n' ⊨ uᵢ)`。
        4.  由于 `elements(())` 是空集 `∅`，`∀uᵢ ∈ ∅` 的全称量化命题是**空虚地为真 (vacuously true)**。
        5.  因此，`M, n ⊨ Quote(())` 恒成立。
        6.  由于 `M` 是任意的，`Ξ ⊨ Quote(()) @ n`。

*   **归纳步骤**: 假设对于所有长度小于 `k` (`k > 1`) 的推导，定理均成立（归纳假设，IH）。现证明长度为 `k` 的推导同样满足定理。设 `(Ξ, n) ⊢ u` 是一个长度为 `k` 的推导的最终判断，其最后一步应用了某条推理规则。

    *   **情况 2.1: 继承规则 (规则 2)**
        1.  前提：`(Ξ, n) ⊢ u` 由 `(Ξ, p) ⊢ u` 和 `p > n` 得出。推导 `(Ξ, p) ⊢ u` 的长度小于 `k`。
        2.  根据 (IH)，`Ξ ⊨ u @ p`。这意味着对于任意有效模型 `M`，均有 `M, p ⊨ u`。
        3.  令 `M` 为任意有效模型。则 `M, p ⊨ u`。
        4.  由于 `p > n`，即 `(p, n) ∈ R`，根据有效模型的**继承为真**条件，若 `M, p ⊨ u`，则 `M, n ⊨ u`。
        5.  因此 `M, n ⊨ u`。由于 `M` 是任意的，故 `Ξ ⊨ u @ n`。

    *   **情况 2.2: 蕴含消除规则 (规则 3)**
        1.  前提：`(Ξ, n) ⊢ u₂` 由 `(Ξ, n) ⊢ (u₁ → u₂)` 和 `(Ξ, n) ⊢ u₁` 得出。这两个前提的推导长度均小于 `k`。
        2.  根据 (IH)，`Ξ ⊨ (u₁ → u₂) @ n` 且 `Ξ ⊨ u₁ @ n`。
        3.  令 `M` 为任意有效模型。则 `M, n ⊨ (u₁ → u₂)` 且 `M, n ⊨ u₁`。
        4.  根据 `→` 的满足关系定义，`M, n ⊨ (u₁ → u₂)` 等价于 `(M, n ⊨ u₁) ⇒ (M, n ⊨ u₂)`。
        5.  由 (3) 和 (4)，通过元语言的肯定前件式，可得 `M, n ⊨ u₂`。
        6.  由于 `M` 是任意的，故 `Ξ ⊨ u₂ @ n`。

    *   **情况 2.3: 引用引入规则 (规则 5)**
        1.  前提：`(Ξ, n) ⊢ Quote(S)` 由 `∀uᵢ ∈ elements(S), (Ξ, n) ⊢ uᵢ` 得出，其中 `S` 为非空序列。对每个 `uᵢ` 的推导长度均小于 `k`。
        2.  根据 (IH)，`∀uᵢ ∈ elements(S), Ξ ⊨ uᵢ @ n`。
        3.  令 `M` 为任意有效模型。根据 (2)，`∀uᵢ ∈ elements(S), M, n ⊨ uᵢ`。
        4.  我们需要证明 `M, n ⊨ Quote(S)`。根据定义，这需要证明 `∀uᵢ ∈ elements(S), ∀n' ∈ N, ((n, n') ∈ R ⇒ M, n' ⊨ uᵢ)`。
        5.  取任意 `uᵢ ∈ elements(S)` 和任意 `n'` 使得 `(n, n') ∈ R`。
        6.  我们已知 `M, n ⊨ uᵢ` (来自 3) 且 `M` 是有效模型。根据**继承为真**条件，`M, n ⊨ uᵢ` 和 `(n, n') ∈ R` 蕴含 `M, n' ⊨ uᵢ`。
        7.  由于 `uᵢ` 和 `n'` 是任意选择的，因此 (4) 中的条件成立。故 `M, n ⊨ Quote(S)`。
        8.  由于 `M` 是任意的，故 `Ξ ⊨ Quote(S) @ n`。

归纳步骤对所有规则均已证明。因此，该定理成立。∎

#### **6.2. 非平凡一致性 (Non-trivial Consistency)**

**定理**: HCL 系统是一致的。即，存在一个上下文树 `Ξ`、一个节点 `n` 和一个公式 `u`，使得 `(Ξ, n) \nvdash u`。

**证明**: 通过构造一个具体的有效模型来证明。

1.  设原子公式集合 `A = {a}`。
2.  定义上下文树 `Ξ₀ = (N₀, E₀, C₀)`，其中：
    *   `N₀ = {n₀}`
    *   `E₀ = ∅`
    *   `C₀` 是为 `n₀` 分配空序列的函数，即 `C₀(n₀) = ()`。
3.  基于 `Ξ₀` 定义一个克里普克-HCL 模型 `M₀ = (Ξ₀, R₀, V₀)`：
    *   `Ξ₀` 如上定义。
    *   `R₀ = ∅`，因为 `E₀` 为空。
    *   `V₀` 是赋值函数，定义为 `V₀(n₀, a) = False`。
4.  **检验 `M₀` 的有效性**：
    *   **公理为真**: `elements(C₀(n₀))` 为空集，因此该条件被**空虚地**满足。
    *   **继承为真**: `R₀` 为空集，因此该条件被**空虚地**满足。
    *   结论：`M₀` 是一个有效的克里普克-HCL 模型。
5.  **评估公式 `a` 的真值**：
    *   根据满足关系的定义，`M₀, n₀ ⊨ a` 当且仅当 `V₀(n₀, a) = True`。
    *   根据 `V₀` 的构造，`V₀(n₀, a) = False`。因此，`M₀, n₀ ⊨ a` 是**假**的。
6.  **应用语义推论的定义**：
    *   由于存在一个有效的模型 (`M₀`) 使得 `M₀, n₀ ⊨ a` 为假，因此 `a` 不是 `Ξ₀` 在 `n₀` 上的语义推论。即 `Ξ₀ ⊨ a @ n₀` 不成立。
7.  **应用可靠性定理**：
    *   可靠性定理的逆否命题是：若 `Ξ ⊨ u @ n` 不成立，则 `(Ξ, n) ⊢ u` 不成立。
    *   将此应用于我们的结果：因为 `Ξ₀ ⊨ a @ n₀` 不成立，所以 `(Ξ₀, n₀) \nvdash a`。
8.  **结论**：我们已经证明了判断 `(Ξ₀, n₀) \vdash a` 是不可推导的。因此，HCL 系统不是平凡的，即它是一致的。∎