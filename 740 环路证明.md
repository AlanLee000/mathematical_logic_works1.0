### 1. 基础类型系统 (Type System)

我们首先定义逻辑命题的载体。

**定义 1.1（原子类型集合）**
设 $\mathbb{A}$ 为一个可数的原子命题符号集（如 $\{p, q, r, ...\}$）。

**定义 1.2（极性类型）**
类型集合 $\mathcal{T}$ 定义为：
$$ \mathcal{T} = \{ \phi^+ \mid \phi \in \mathbb{A} \} \cup \{ \phi^- \mid \phi \in \mathbb{A} \} $$
*   $\phi^+$ 表示资源 $\phi$ 的**产出**（Output/Source）。
*   $\phi^-$ 表示资源 $\phi$ 的**消耗**（Input/Sink）。
*   对偶运算：$\overline{\phi^+} = \phi^-$，$\overline{\phi^-} = \phi^+$。

**定义 1.3（接口签名）**
一个**接口签名** $\Sigma$ 是一个类型的有序元组：
$$ \Sigma = \langle t_1, t_2, ..., t_k \rangle, \quad t_i \in \mathcal{T} $$

---

### 2. 证明对象的层级构造 (Iterative Construction)

证明对象并非一次性生成的树，而是按层级（Rank）递归构造的实体。每一层的“图”在被封装后，成为下一层的“节点”。

令 $\mathcal{C}_k$ 表示第 $k$ 层组件（Component）的集合。

#### 第 0 层：原生逻辑门 (Primitives)
**定义 2.1（$\mathcal{C}_0$ 集合）**
$\mathcal{C}_0$ 包含基础逻辑算子。每个组件 $c \in \mathcal{C}_0$ 由三元组定义：
$$ c = (\mathbf{in}, \mathbf{out}, f_c) $$
其中：
*   $\mathbf{in} \in \mathcal{T}^*$ 是输入类型序列。
*   $\mathbf{out} \in \mathcal{T}^*$ 是输出类型序列。
*   $f_c: \text{Dom}(\mathbf{in}) \to \text{Dom}(\mathbf{out})$ 是该组件的局部转换函数（语义核）。

*示例（同一律门）：*
$ID_p = (\langle p^- \rangle, \langle p^+ \rangle, f(x)=x)$。

#### 第 $k+1$ 层：图的物化 (Reification)
为了定义 $\mathcal{C}_{k+1}$，我们必须先定义由 $\mathcal{C}_k$ 构成的**证明图（Proof Graph）**。

**定义 2.2（证明图）**
一个基于组件集 $\mathcal{C}_k$ 的证明图是一个四元组 $G = (V, P, E, \alpha)$，其中：

1.  **节点集 $V$**：有限集合 $\{v_1, ..., v_n\}$。
2.  **组件指派 $\alpha$**：映射 $\alpha: V \to \mathcal{C}_k$，将每个节点映射到一个第 $k$ 层的组件。
3.  **端口集 $P$**：
    *   对于每个节点 $v$，若 $\alpha(v) = (\mathbf{in}, \mathbf{out}, f)$，则 $v$ 拥有输入端口集 $P_{in}(v)$ 和输出端口集 $P_{out}(v)$。
    *   $P = \bigcup_{v \in V} (P_{in}(v) \cup P_{out}(v))$。
4.  **边集 $E$（有向流）**：
    *   $E$ 是有序对 $(p_{src}, p_{dst})$ 的集合，其中 $p_{src} \in P_{out}(u)$，$p_{dst} \in P_{in}(v)$（$u, v \in V$）。
    *   **限制**：每个端口至多连接一条边（线性逻辑约束，防止未显式定义的复制/丢弃）。

**定义 2.3（物化算子 $\downarrow$）**
给定一个证明图 $G$，我们可以将其**物化**为一个第 $k+1$ 层的单一组件 $c_{new} = \downarrow G$。
$$ \downarrow G \in \mathcal{C}_{k+1} $$
该新组件的定义如下：
*   **输入接口**：$G$ 中所有未被连接的输入端口序列。
*   **输出接口**：$G$ 中所有未被连接的输出端口序列。
*   **内部结构**：图 $G$ 本身成为 $c_{new}$ 的黑盒定义。

---

### 3. 合法性约束 (Validity Constraints)

任何构造出的证明图 $G$ 必须满足两个核心公理才能被视为“有效句法”。

#### 公理 A：局部类型匹配 (Local Type Matching)
对于 $G$ 中的每一条边 $e = (p_{u}, p_{v}) \in E$：
设端口 $p_{u}$ 的类型为 $t_{out}$，端口 $p_{v}$ 的类型为 $t_{in}$。
必须满足：
$$ t_{out} = \overline{t_{in}} $$
即：输出的类型必须与输入的类型互为对偶（例如 $A^+$ 连接到 $A^-$）。

#### 公理 B：拓扑关联守恒 (Topological Incidence Conservation)

我们引入一种纯句法的判定标准，要求证明图中的递归结构在拓扑连接上保持严格的“输入-输出对称性”。

**定义 3.1（基本环路）**
设 $G=(V, E)$ 为证明图。一个**基本环路 (Elementary Cycle)** $C$ 是 $G$ 的一个子图，其节点序列 $v_1, \dots, v_m$ 满足 $v_1 = v_m$，且在该序列中除起点和终点外没有重复节点（简单环）。

**定义 3.2（外部邻接集）**
对于基本环路 $C$ 上的任意节点 $x \in V(C)$，我们定义其**除去环路后**的外部邻接节点集：

*   **外部源集 (External Source Set)** $\Gamma_{in}(x)$：
    指所有**不在**环路 $C$ 上，但有一条边直接指向 $x$ 的节点集合。
    $$ \Gamma_{in}(x) = \{ u \in V \setminus V(C) \mid (u, x) \in E \} $$
*   **外部靶集 (External Target Set)** $\Gamma_{out}(x)$：
    指所有**不在**环路 $C$ 上，且 $x$ 有一条边直接指向它的节点集合。
    $$ \Gamma_{out}(x) = \{ v \in V \setminus V(C) \mid (x, v) \in E \} $$

**公理 B（两点关联守恒）**
对于图 $G$ 中的任意基本环路 $C$，以及该环路上的**任意两个节点** $u, v \in V(C)$（允许 $u=v$），必须满足以下两个集合论等式：

1.  **并集守恒（覆盖域一致）**：
    两点通达的外部节点的对称差集，必须等于两点来源的外部节点的对称差集。
    $$ \Gamma_{out}(u) \Delta \Gamma_{out}(v) = \Gamma_{in}(u) \Delta \Gamma_{in}(v) $$

2.  **交集守恒（重叠度一致）**：
    两点分别通达和来源节点的交集，必须等于两点分别来源和通达的外部节点交集。
    $$ \Gamma_{out}(u) \cap \Gamma_{in}(v) = \Gamma_{in}(u) \cap \Gamma_{out}(v) $$

---

### 4. 证明对象 (The Proof Object)

**定义 4.1（$\mathcal{L}_{\circlearrowleft}$ 证明）**
一个 $\mathcal{L}_{\circlearrowleft}$ 系统中的**证明** $\Pi$ 是一个满足以下条件的元组：
$$ \Pi = (k, \mathcal{G}_{root}) $$
其中：
1.  $k \in \mathbb{N}$ 是层级深度。
2.  $\mathcal{G}_{root}$ 是一个第 $k$ 层的证明图（顶层图）。
3.  $\mathcal{G}_{root}$ 必须是**闭合的**（Closed），即没有未连接的输入/输出端口（所有推演步骤都在内部完成，形成自洽系统），或者仅暴露出待证明命题的输入/输出接口。
4.  $\mathcal{G}_{root}$ 及其内部所有递归物化的子图，都必须满足 **公理 A（类型匹配）** 和 **公理 B（环路守恒）**。

---