## **BTN 计算等价形式系统 (BTN-CES)**

### **1. 语法 (Syntax)**

#### **1.1 基本集合**
- **变量标识符集**: $\mathcal{V}_{id} = \mathbb{N} = \{0, 1, 2, \dots\}$
- **常量集**: $\mathcal{C} = \{\mathsf{app}, \mathsf{var}, \mathsf{neg}, \mathsf{forall}, \mathsf{to}, \mathsf{lack}_1, \mathsf{lack}_2, \mathsf{false}, \mathsf{lam}\}$

#### **1.2 项 (Term)**
$$
\begin{align*}
t \in \mathsf{Term} ::= \ & \mathsf{var}(i) & & \text{（其中 } i \in \mathbb{N} \text{）} \\
       & \mid \mathsf{const}(c) & & \text{（其中 } c \in \mathcal{C} \text{）} \\
       & \mid \mathsf{pairT}(t_1, t_2) & & \text{（其中 } t_1, t_2 \in \mathsf{Term} \text{）} \\
       & \mid \mathsf{appT}(t_1, t_2) & & \text{（其中 } t_1, t_2 \in \mathsf{Term} \text{）} \\
       & \mid \mathsf{lamT}(i, t) & & \text{（其中 } i \in \mathbb{N}, t \in \mathsf{Term} \text{）}
\end{align*}
$$

#### **1.3 值 (Value)**
$$
\begin{align*}
v \in \mathsf{Value} ::= \ & \mathsf{constV}(c) & & \text{（其中 } c \in \mathcal{C} \text{）} \\
       & \mid \mathsf{natV}(i) & & \text{（其中 } i \in \mathbb{N} \text{）} \\
       & \mid \mathsf{pairV}(v_1, v_2) & & \text{（其中 } v_1, v_2 \in \mathsf{Value} \text{）} \\
       & \mid \mathsf{appV}(v_1, v_2) & & \text{（其中 } v_1, v_2 \in \mathsf{Value} \text{）} \\
       & \mid \mathsf{lamV}(i, v_t) & & \text{（其中 } i \in \mathbb{N}, v_t \in \mathsf{Value} \text{）}
\end{align*}
$$

### **2. 辅助元函数与谓词**

#### **2.1 自由变量函数 $FV: \mathsf{Term} \to \mathcal{P}(\mathbb{N})$**
- $FV(\mathsf{var}(i)) = \{i\}$
- $FV(\mathsf{const}(c)) = \emptyset$
- $FV(\mathsf{pairT}(t_1,t_2)) = FV(t_1) \cup FV(t_2)$
- $FV(\mathsf{appT}(t_1,t_2)) = FV(t_1) \cup FV(t_2)$
- $FV(\mathsf{lamT}(i,t)) = FV(t) \setminus \{i\}$

#### **2.2 项编码函数 $\mathsf{encodeTerm}: \mathsf{Term} \to \mathsf{Value}$**
- $\mathsf{encodeTerm}(\mathsf{var}(i)) = \mathsf{pairV}(\mathsf{constV}(\mathsf{var}), \mathsf{natV}(i))$
- $\mathsf{encodeTerm}(\mathsf{const}(c)) = \mathsf{constV}(c)$
- $\mathsf{encodeTerm}(\mathsf{pairT}(t_1,t_2)) = \mathsf{pairV}(\mathsf{encodeTerm}(t_1), \mathsf{encodeTerm}(t_2))$
- $\mathsf{encodeTerm}(\mathsf{appT}(t_1,t_2)) = \mathsf{appV}(\mathsf{encodeTerm(t_1)}, \mathsf{encodeTerm}(t_2))$
- $\mathsf{encodeTerm}(\mathsf{lamT}(i,t)) = \mathsf{lamV}(i, \mathsf{encodeTerm}(t))$

#### **2.3 项替换函数 $\mathsf{subst\_term}: \mathsf{Term} \times \mathbb{N} \times \mathsf{Value} \to \mathsf{Term}$**
设 $t_{\text{sub}} = \mathsf{valueToTerm}(v_{\text{sub}})$（此处的 `valueToTerm` 为 `encodeTerm` 的逆操作）：
- $\mathsf{subst\_term}(\mathsf{var}(j), i, v_{\text{sub}}) = \begin{cases} t_{\text{sub}} & j = i \\ \mathsf{var}(j) & j \neq i \end{cases}$
- $\mathsf{subst\_term}(\mathsf{const}(c), i, v_{\text{sub}}) = \mathsf{const}(c)$
- $\mathsf{subst\_term}(\mathsf{pairT}(t_1,t_2), i, v_{\text{sub}}) = \mathsf{pairT}(\mathsf{subst\_term}(t_1,i,v_{\text{sub}}), \mathsf{subst\_term}(t_2,i,v_{\text{sub}}))$
- $\mathsf{subst\_term}(\mathsf{appT}(t_1,t_2), i, v_{\text{sub}}) = \mathsf{appT}(\mathsf{subst\_term}(t_1,i,v_{\text{sub}}), \mathsf{subst\_term}(t_2,i,v_{\text{sub}}))$
- $\mathsf{subst\_term}(\mathsf{lamT}(j,t), i, v_{\text{sub}}) = $
$$
\begin{cases} 
\mathsf{lamT}(j,t) & j = i \\
\mathsf{lamT}(j, \mathsf{subst\_term}(t,i,v_{\text{sub}})) & j \neq i \land j \notin FV(t_{\text{sub}}) \\
\mathsf{lamT}(k, \mathsf{subst\_term}(\mathsf{subst\_term}(t, j, \mathsf{natV}(k)),i,v_{\text{sub}})) & j \neq i \land j \in FV(t_{\text{sub}}), \\
& \text{其中 } k = \min \{ m \mid m \notin FV(t) \cup FV(t_{\text{sub}}) \}
\end{cases}
$$

#### **2.4 公式谓词**
元谓词 $\mathsf{IsFormula}(v)$ 定义为真，当且仅当值 $v$ 可以被（原始报告 §2.2 中定义的）`decode` 函数成功解码为一个合法的逻辑公式。元函数 $\mathsf{decode}(v)$ 返回该公式。

### **3. 判断 (Judgment)**

本系统的核心判断是 **计算等价性 (Calculational Equivalence)**，写作：
$$ \vdash v_1 \equiv v_2 $$

### **4. 推理规则 (Inference Rules)**

#### **4.1 公理**
$$
\overline{\vdash \mathsf{constV}(\mathsf{false}) \equiv \mathsf{constV}(\mathsf{app})} \quad (\text{Ax-Split})
$$

$$
\frac{F = \mathsf{lamV}(i, \mathsf{encodeTerm}(s)) \quad s' = \mathsf{subst\_term}(s, i, A)}{\vdash \mathsf{appV}(F, A) \equiv \mathsf{encodeTerm}(s')} \quad (\text{Ax-Beta})
$$

#### **4.2 等价规则**
$$
\frac{}{\vdash v \equiv v} \quad (\text{Refl})
$$

$$
\frac{\vdash v_1 \equiv v_2}{\vdash v_2 \equiv v_1} \quad (\text{Symm})
$$

$$
\frac{\vdash v_1 \equiv v_2 \quad \vdash v_2 \equiv v_3}{\vdash v_1 \equiv v_3} \quad (\text{Trans})
$$

#### **4.3 合同性规则 (Congruence Rules)**
$$
\frac{\vdash v_1 \equiv w_1 \quad \vdash v_2 \equiv w_2}{\vdash \mathsf{pairV}(v_1, v_2) \equiv \mathsf{pairV}(w_1, w_2)} \quad (\text{Cong-Pair})
$$

$$
\frac{\vdash v_1 \equiv w_1 \quad \vdash v_2 \equiv w_2}{\vdash \mathsf{appV}(v_1, v_2) \equiv \mathsf{appV}(w_1, w_2)} \quad (\text{Cong-App})
$$

$$
\frac{\vdash v_t \equiv w_t}{\vdash \mathsf{lamV}(i, v_t) \equiv \mathsf{lamV}(i, w_t)} \quad (\text{Cong-Lam})
$$

#### **4.4 全局一致性约束 (Global Consistency Constraint)**
对于任意由本系统可推导的判断 $\vdash v_1 \equiv v_2$，若元谓词 $\mathsf{IsFormula}(v_1)$ 与 $\mathsf{IsFormula}(v_2)$ 均为真，则必须在元逻辑中成立 $\mathsf{decode}(v_1) \leftrightarrow \mathsf{decode}(v_2)$。

### **5. 核心定理：语法-语义分裂定理**

**定理陈述**：
在本形式系统 **BTN-CES** 中，存在两个语法上不相等的值 $v_a, v_b \in \mathsf{Value}$（即 $v_a \neq v_b$），使得它们的计算等价性判断 $\vdash v_a \equiv v_b$ 是可证的。

**证明**:
1.  **选择值**:
    令 $v_a = \mathsf{constV}(\mathsf{false})$
    令 $v_b = \mathsf{constV}(\mathsf{app})$

2.  **语法不等性**:
    根据 $\mathsf{Value}$ 的定义，由于常量 $\mathsf{false} \neq \mathsf{app}$，故 $v_a \neq v_b$。

3.  **计算等价性证明**:
    根据公理 $(\text{Ax-Split})$，我们有：
    $$
    \overline{\vdash \mathsf{constV}(\mathsf{false}) \equiv \mathsf{constV}(\mathsf{app})}
    $$
    这是一个公理，因此该判断是直接可证的。

**结论**:
我们找到了两个语法不同的值 $v_a$ 和 $v_b$，它们在本系统中被断言为计算等价。这证明了系统的计算等价关系（语义层面）与其值的语法身份（语法层面）之间存在分裂。**证毕**。