(* Coq 8.13+ *)
Require Import Coq.Lists.List.
Require Import Coq.Arith.Arith.
Require Import Coq.micromega.Lia.

Set Implicit Arguments.
Open Scope list_scope.
Open Scope nat_scope.

(******************************************************************************)
(** * Part 1: Syntax of the Formal System H *)
(******************************************************************************)

(** 1.1. Alphabet *)

(** Variables are represented by natural numbers. This provides a countably
    infinite set V. *)
Definition var := nat.

(** The three binary operators. *)
Inductive Operator : Type :=
| Implies  (* → *)
| Tilde    (* ~ *)
| NEquals  (* ≠ *).

(** 1.2. Well-Formed Expressions (WFE) *)

(** The set W of well-formed expressions is defined inductively. *)
Inductive WFE : Type :=
| Var : var -> WFE
| Op  : Operator -> WFE -> WFE -> WFE.

(** Notations for readability, matching the specification. *)
Notation "φ → ψ" := (Op Implies φ ψ) (at level 95, right associativity).
Notation "φ ~ ψ" := (Op Tilde φ ψ) (at level 95, right associativity).
Notation "φ ≠ ψ" := (Op NEquals φ ψ) (at level 70, no associativity).

(******************************************************************************)
(** * Part 2: Proof System of H *)
(******************************************************************************)

(** 2.1. Derivability *)

(** The derivability relation Γ ⊢ φ is defined as an inductive predicate.
    Each constructor corresponds to an axiom, an assumption from the context,
    or an inference rule. *)

Inductive derives (Γ : list WFE) : WFE -> Prop :=
| InHyp (φ : WFE) :
    In φ Γ ->
    derives Γ φ

(** 2.2. Axiom Schemas *)
| Ax1 (φ ψ : WFE) :
    derives Γ (φ ≠ (φ → ψ))
| Ax2 (φ ψ : WFE) :
    derives Γ (φ ≠ (φ ~ ψ))

(** 2.3. Rules of Inference *)
| R1_HypergraphTransitivity (φ ψ χ : WFE) :
    derives Γ (φ → ψ) ->
    derives Γ (φ ~ χ) ->
    derives Γ ((φ → ψ) ~ χ)
| R2_ConnectionRedirection (φ ψ χ ω : WFE) :
    derives Γ (φ → (ψ ~ χ)) ->
    derives Γ (χ ~ ω) ->
    derives Γ (φ → (χ ~ ω))
| R3_CoMembershipSymmetry (φ ψ : WFE) :
    derives Γ (φ ~ ψ) ->
    derives Γ (ψ ~ φ)
| R4_Exclusion (φ ψ χ : WFE) :
    derives Γ (φ → ψ) ->
    derives Γ (φ ~ χ) ->
    derives Γ (ψ ≠ χ)
| R5_InequalitySymmetry (φ ψ : WFE) :
    derives Γ (φ ≠ ψ) ->
    derives Γ (ψ ≠ φ)
| R6a_StructuralCongruenceIneq_L (φ ψ α : WFE) (op : Operator) :
    derives Γ (φ ≠ ψ) ->
    derives Γ ((Op op α φ) ≠ (Op op α ψ))
| R6b_StructuralCongruenceIneq_R (φ ψ α : WFE) (op : Operator) :
    derives Γ (φ ≠ ψ) ->
    derives Γ ((Op op φ α) ≠ (Op op ψ α))
| R7_OperatorDistinction (φ₁ φ₂ ψ₁ ψ₂ : WFE) :
    derives Γ ((φ₁ → φ₂) ≠ (ψ₁ ~ ψ₂)).

(** Notation for derivability. *)
Notation "Γ ⊢ φ" := (derives Γ φ) (at level 60).
Notation "⊢ φ" := (derives nil φ) (at level 60).


(******************************************************************************)
(** * Part 3: Semantics - A Hyper-DiGraph Model M *)
(******************************************************************************)

Module Semantics.

(** 3.1.1. Domain: The domain D is the set of all WFEs. *)
Definition D := WFE.

(** 3.1.2. Interpretation Function I *)

(** A. The inequality relation ≠ᴹ is syntactic inequality. *)
Definition neq_M (φ ψ : D) : Prop := φ <> ψ.

(** B. The relations →ᴹ and ~ᴹ are defined via the minimal set T. *)

(** Step 1: Base structure S = (V, E, H) on variables. *)

(** The directed edge set E := { (vᵢ, vᵢ₊₁) | i is even } *)
Definition E_rel (u v : var) : Prop :=
  exists i, u = 2 * i /\ v = 2 * i + 1.

(** The hyperedge set H := { {vᵢ, vᵢ₊₂} | i ∈ ℕ } *)
Definition H_rel (u v : var) : Prop :=
  exists i, (u = i /\ v = i + 2) \/ (u = i + 2 /\ v = i).

(** Step 2: The minimal set T of "true" propositions. *)

Inductive T : WFE -> Prop :=
(** Basis Terms *)
| T_base_implies (u v : var) :
    E_rel u v ->
    T (Var u → Var v)
| T_base_tilde (u v : var) :
    H_rel u v ->
    T (Var u ~ Var v)
(** Closure Clauses (mirroring rules R1, R2, R3) *)
| C1 (φ ψ χ : WFE) :
    T (φ → ψ) ->
    T (φ ~ χ) ->
    T ((φ → ψ) ~ χ)
| C2 (φ ψ χ ω : WFE) :
    T (φ → (ψ ~ χ)) ->
    T (χ ~ ω) ->
    T (φ → (χ ~ ω))
| C3 (φ ψ : WFE) :
    T (φ ~ ψ) ->
    T (ψ ~ φ).

(** Step 3: Define →ᴹ and ~ᴹ based on T. *)

Definition impl_M (φ ψ : D) : Prop := T (φ → ψ).
Definition tilde_M (φ ψ : D) : Prop := T (φ ~ ψ).

(** 3.2. Satisfaction *)

(** Satisfaction of a single WFE in the model M. *)
Definition holds (φ : WFE) : Prop :=
  match φ with
  | Var _ => False (* Variables are not propositions in this system *)
  | Op op φ₁ φ₂ =>
    match op with
    | Implies => impl_M φ₁ φ₂
    | Tilde   => tilde_M φ₁ φ₂
    | NEquals => neq_M φ₁ φ₂
    end
  end.

(** Satisfaction of a context Γ. *)
Definition holds_context (Γ : list WFE) : Prop :=
  forall φ, In φ Γ -> holds φ.

(** Notations for satisfaction have been removed to avoid ambiguity.
    We now use 'holds' for single WFEs and 'holds_context' for lists of WFEs directly. *)
(* Notation "'M' ⊨ φ" := (holds φ) (at level 60). *)
(* Notation "'M' ⊨ Γ" := (holds_context Γ) (at level 60). *)

End Semantics.

Import Semantics.


(******************************************************************************)
(** * Part 4: Soundness Proof *)
(******************************************************************************)

(** The goal is to prove that if Γ ⊢ φ, then Γ ⊨ φ.
    Theorem Soundness: forall Γ φ, Γ ⊢ φ -> holds Γ -> holds φ.
*)

Section SoundnessProof.

Context {Γ : list WFE}.

(** We prove the soundness of each axiom and rule as a lemma. *)

(** 3.3.1. Axiom Validation *)

Lemma soundness_Ax1 (φ ψ : WFE) : holds (φ ≠ (φ → ψ)).
Proof.
  unfold holds, neq_M. intro H_contra.
  destruct φ; discriminate.
Qed.

Lemma soundness_Ax2 (φ ψ : WFE) : holds (φ ≠ (φ ~ ψ)).
Proof.
  unfold holds, neq_M. intro H_contra.
  destruct φ; discriminate.
Qed.


(** 3.3.2. Inference Rule Validation *)

Lemma soundness_R1 (φ ψ χ : WFE) :
  holds (φ → ψ) -> holds (φ ~ χ) -> holds ((φ → ψ) ~ χ).
Proof.
  unfold holds, impl_M, tilde_M.
  intros H_impl H_tilde.
  apply C1; assumption.
Qed.

Lemma soundness_R2 (φ ψ χ ω : WFE) :
  holds (φ → (ψ ~ χ)) -> holds (χ ~ ω) -> holds (φ → (χ ~ ω)).
Proof.
  unfold holds, impl_M, tilde_M.
  intros H1 H2.
  apply C2; assumption.
Qed.

Lemma soundness_R3 (φ ψ : WFE) :
  holds (φ ~ ψ) -> holds (ψ ~ φ).
Proof.
  unfold holds, tilde_M.
  intro H.
  apply C3; assumption.
Qed.

(** Rule R4 is the most complex one. We first prove the key lemma identified
    in the informal proof description. *)

(** Key Lemma: If (α → β) is in T, then α must be a variable. *)
Lemma T_impl_lhs_is_var (α β : WFE) :
  T (α → β) -> exists v : var, α = Var v.
Proof.
  intro H_T.
  induction H_T.
  - (* T_base_implies *)
    exists u. reflexivity.
  - (* T_base_tilde: impossible case *)
    inversion H.
  - (* C1: impossible case *)
    inversion H.
  - (* C2 *)
    apply IHH_T.
  - (* C3: impossible case *)
    inversion H.
Qed.

(** With the lemma, we can now prove the soundness of R4. *)

(** Helper Lemma: Establishes structural properties of expressions in T. *)
Lemma T_structural_properties : forall w (H : T w),
  (forall v psi, w = (Var v -> psi) -> (exists v_psi, psi = Var v_psi) \/ (exists a b, psi = a ~ b))
  /\
  (forall v chi, (w = (Var v ~ chi) \/ w = (chi ~ Var v)) -> (exists v_chi, chi = Var v_chi) \/ (exists a b, chi = a -> b)).
Proof.
  induction H; split; intros v t H_eq.
  - (* Property for -> *)
    destruct H_eq as H_eq'.
    + inversion H_eq'; subst; auto.
    + discriminate H_eq'.
    + discriminate H_eq'.
    + inversion H_eq'; subst; right; eauto.
    + discriminate H_eq'.
  - (* Property for ~ *)
    destruct H_eq as [H_eq' | H_eq'].
    + (* Case w = Var v ~ t *)
      * inversion H_eq'; subst; auto.
      * discriminate H_eq'.
      * inversion H_eq'; subst.
        destruct IHH as [_ H_tilde_prop].
        apply (H_tilde_prop v t). right. reflexivity.
    + (* Case w = t ~ Var v *)
      * inversion H_eq'; subst; auto.
      * inversion H_eq'; subst.
        right. eauto.
      * inversion H_eq'; subst.
        destruct IHH as [_ H_tilde_prop].
        apply (H_tilde_prop v t). left. reflexivity.
Qed.

Lemma soundness_R4 (φ ψ χ : WFE) :
  holds (φ → ψ) -> holds (φ ~ χ) -> holds (ψ ≠ χ).
Proof.
  unfold holds, impl_M, tilde_M, neq_M.
  intros H_impl H_tilde.

  (* Step 4 from informal proof: φ must be a variable. *)
  pose proof (T_impl_lhs_is_var _ _ H_impl) as [v H_phi_eq].
  subst φ.

  (* Now we have:
     H_impl : T (Var v → ψ)
     H_tilde : T (Var v ~ χ)
     Goal: ψ <> χ
  *)

  (* Structural analysis using the helper lemma *)
  destruct (T_structural_properties _ H_impl) as [H_psi_struct_prop _].
  destruct (T_structural_properties _ H_tilde) as [_ H_chi_struct_prop].

  assert (H_psi_struct : (exists v_psi, ψ = Var v_psi) \/ (exists a b, ψ = a ~ b))
    by (eapply H_psi_struct_prop; eauto).

  assert (H_chi_struct : (exists v_chi, χ = Var v_chi) \/ (exists a b, χ = a → b))
    by (eapply H_chi_struct_prop; eauto; left; reflexivity).

  (* Step 7: Case analysis on the structures of ψ and χ *)
  destruct H_psi_struct as [[v_psi H_psi_eq] | [a_psi [b_psi H_psi_eq]]].
  - (* Case: ψ is a variable *)
    subst ψ.
    destruct H_chi_struct as [[v_chi H_chi_eq] | [a_chi [b_chi H_chi_eq]]].
    + (* Subcase: χ is also a variable *)
      subst χ. intro H_contra_eq. injection H_contra_eq; intros ->.
      (* We have T (Var v -> Var v_psi) and T (Var v ~ Var v_psi).
         This must come from the base cases. *)
      assert (E_rel v v_psi). { induction H_impl; auto. discriminate. discriminate. eapply IHH_impl. discriminate. }
      assert (H_rel v v_psi). { induction H_tilde; auto. discriminate. discriminate. apply IHH_tilde. reflexivity. }
      (* Now show E_rel and H_rel on same pair of vars is impossible *)
      unfold E_rel, H_rel in *.
      destruct H as [i [-> ->]].
      destruct H0 as [j [Hj1 | Hj2]].
      * destruct Hj1 as [-> ->]. lia.
      * destruct Hj2 as [-> ->]. lia.
    + (* Subcase: χ is an implies-expression. A var is not an op. *)
      subst χ. intro H_contra. discriminate.
  - (* Case: ψ is a tilde-expression *)
    subst ψ.
    destruct H_chi_struct as [[v_chi H_chi_eq] | [a_chi [b_chi H_chi_eq]]].
    + (* Subcase: χ is a variable. An op is not a var. *)
      subst χ. intro H_contra. discriminate.
    + (* Subcase: χ is an implies-expression. Tilde <> Implies. *)
      subst χ. intro H_contra. discriminate.
Qed.

Lemma soundness_R5 (φ ψ : WFE) :
  holds (φ ≠ ψ) -> holds (ψ ≠ φ).
Proof.
  unfold holds, neq_M.
  intros H. symmetry. assumption.
Qed.

Lemma soundness_R6 (φ ψ α : WFE) (op : Operator) :
  holds (φ ≠ ψ) -> (holds ((Op op α φ) ≠ (Op op α ψ))) /\ (holds ((Op op φ α) ≠ (Op op ψ α))).
Proof.
  unfold holds, neq_M.
  intro H_neq.
  split.
  - intro H_contra. injection H_contra; intros _ H_eq. contradiction.
  - intro H_contra. injection H_contra; intros H_eq _. contradiction.
Qed.

Lemma soundness_R7 (φ₁ φ₂ ψ₁ ψ₂ : WFE) :
  holds ((φ₁ → φ₂) ≠ (ψ₁ ~ ψ₂)).
Proof.
  unfold holds, neq_M.
  intro H_contra. discriminate.
Qed.


(** Main Soundness Theorem *)

Theorem soundness : forall φ, Γ ⊢ φ -> holds Γ -> holds φ.
Proof.
  intros φ H_derives H_holds_gamma.
  induction H_derives.
  - apply H_holds_gamma. assumption.
  - apply soundness_Ax1.
  - apply soundness_Ax2.
  - eapply soundness_R1; eauto.
  - eapply soundness_R2; eauto.
  - apply soundness_R3; auto.
  - eapply soundness_R4; eauto.
  - apply soundness_R5; auto.
  - destruct (soundness_R6 _ _ _ op) as [H_R6a _].
    apply H_R6a; auto.
  - destruct (soundness_R6 _ _ _ op) as [_ H_R6b].
    apply H_R6b; auto.
  - apply soundness_R7.
Qed.

End SoundnessProof.